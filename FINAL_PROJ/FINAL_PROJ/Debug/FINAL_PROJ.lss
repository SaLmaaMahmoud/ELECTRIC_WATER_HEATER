
FINAL_PROJ.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000c6  00000000  00000000  00000134  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000000c6  000002e4  2**0
                  ALLOC
  2 .bss          00000031  00800060  00800060  00000c95  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  00000c95  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000002f8  00000000  00000000  00000cc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003d56  00000000  00000000  00000fbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000fb8  00000000  00000000  00004d12  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001312  00000000  00000000  00005cca  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000055c  00000000  00000000  00006fdc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000531  00000000  00000000  00007538  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000b32  00000000  00000000  00007a69  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000228  00000000  00000000  0000859b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000004  00000b48  00000b48  00000c7c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000087c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text.cooling_Init 0000000c  00000ae4  00000ae4  00000c18  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.cooling_set_state 00000020  000009ec  000009ec  00000b20  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.EEPROM_Init 00000006  00000b36  00000b36  00000c6a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.EEPROM_Write 00000028  00000958  00000958  00000a8c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.OFF_STATE 00000016  00000a8a  00000a8a  00000bbe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.EXT_voidEnableExtInt 000000d2  0000029a  0000029a  000003ce  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.GPIO_voidSetPortDirection 00000058  0000082e  0000082e  00000962  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.GPIO_voidSetPortPinDirection 000000ea  000000c6  000000c6  000001fa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.GPIO_voidSetPortPinValue 000000ea  000001b0  000001b0  000002e4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.GPIO_voidSetPortValue 00000020  00000a0c  00000a0c  00000b40  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.GPIO_voidTogglePortPinValue 00000068  00000638  00000638  0000076c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.GPIO_u8GetPortValue 00000024  000009a6  000009a6  00000ada  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.heating_Init 0000000c  00000af0  00000af0  00000c24  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.heating_set_state 00000020  00000a2c  00000a2c  00000b60  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.I2C_Init 00000012  00000ab4  00000ab4  00000be8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.TWIStart 0000000c  00000afc  00000afc  00000c30  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.TWIStop 00000006  00000b3c  00000b3c  00000c70  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.TWIWrite 0000000e  00000ad6  00000ad6  00000c0a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.LED_ON  0000000c  00000b08  00000b08  00000c3c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.LED_OFF 0000000c  00000b14  00000b14  00000c48  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.LED_Init 00000010  00000ac6  00000ac6  00000bfa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.LED_Blink 0000000a  00000b2c  00000b2c  00000c60  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.Save_Last_Temp 0000000c  00000b20  00000b20  00000c54  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .text.main    00000066  00000708  00000708  0000083c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .text.__vector_3 0000006a  000005ce  000005ce  00000702  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .bss.current_state 00000001  0080009f  0080009f  00000c95  2**0
                  ALLOC
 40 .data.current_mode 00000001  008000a0  00000b5e  00000c92  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 41 .text.SCH_Add_Task 00000068  000006a0  000006a0  000007d4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.SCH_Start 00000004  00000b4c  00000b4c  00000c80  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.SCH_STOP 00000004  00000b50  00000b50  00000c84  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text.SCH_Delete_Task 00000060  0000076e  0000076e  000008a2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .text.SCH_Init_T1 00000046  000008ce  000008ce  00000a02  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .text.SCH_Go_To_Sleep 00000014  00000aa0  00000aa0  00000bd4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .text.SCH_Dispatch_Tasks 00000060  000007ce  000007ce  00000902  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .text.SCH_Update 00000094  00000438  00000438  0000056c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.__vector_7 00000048  00000886  00000886  000009ba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .bss.Error_Code_G 00000002  0080009b  0080009b  00000c95  2**0
                  ALLOC
 51 .text.SSD_TURN_OFF 0000001e  00000a6c  00000a6c  00000ba0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .text.SSD_Init 00000022  000009ca  000009ca  00000afe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .text.SSD_BLINK 00000026  00000980  00000980  00000ab4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .text.segment7_display 00000092  000004cc  000004cc  00000600  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .text.SSD_UPDATE 00000020  00000a4c  00000a4c  00000b80  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .data.ssd     0000000a  00800091  00000b54  00000c88  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 57 .data.SSD_Disp 00000001  008000a1  00000b5f  00000c93  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 58 .data.SSD_MODE 00000001  008000a2  00000b60  00000c94  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 59 .text.SW_Init 00000044  00000914  00000914  00000a48  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .text.Heat_Cool_Elements 00000070  0000055e  0000055e  00000692  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .text.Get_Current_Temp 00000006  00000b42  00000b42  00000c76  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .text.SW_ST   000000cc  0000036c  0000036c  000004a0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .bss.set_temp 00000001  008000a3  008000a3  00000c95  2**0
                  ALLOC
 64 .bss.setting_state_flag 00000002  0080009d  0080009d  00000c95  2**0
                  ALLOC

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 39 00 	jmp	0x72	; 0x72 <__ctors_end>
   4:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
   8:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
   c:	0c 94 e7 02 	jmp	0x5ce	; 0x5ce <__vector_3>
  10:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  14:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  18:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  1c:	0c 94 43 04 	jmp	0x886	; 0x886 <__vector_7>
  20:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  24:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  28:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  2c:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  30:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  34:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  38:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  3c:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  40:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  44:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  48:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  4c:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>
  50:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <__bad_interrupt>

00000054 <.dinit>:
  54:	00 60       	ori	r16, 0x00	; 0
  56:	00 91 80 00 	lds	r16, 0x0080	; 0x800080 <SCH_tasks_G+0x1f>
  5a:	91 00       	.word	0x0091	; ????
  5c:	9b 00       	.word	0x009b	; ????
  5e:	0b 54       	subi	r16, 0x4B	; 75
  60:	00 9b       	sbis	0x00, 0	; 0
  62:	00 a0       	ldd	r0, Z+32	; 0x20
  64:	80 00       	.word	0x0080	; ????
  66:	a0 00       	.word	0x00a0	; ????
  68:	a3 00       	.word	0x00a3	; ????
  6a:	0b 5e       	subi	r16, 0xEB	; 235
  6c:	00 a3       	std	Z+32, r16	; 0x20
  6e:	00 a4       	ldd	r0, Z+40	; 0x28
  70:	80 00       	.word	0x0080	; ????

00000072 <__ctors_end>:
  72:	11 24       	eor	r1, r1
  74:	1f be       	out	0x3f, r1	; 63
  76:	cf e5       	ldi	r28, 0x5F	; 95
  78:	d8 e0       	ldi	r29, 0x08	; 8
  7a:	de bf       	out	0x3e, r29	; 62
  7c:	cd bf       	out	0x3d, r28	; 61

0000007e <__do_copy_data>:
  7e:	e4 e5       	ldi	r30, 0x54	; 84
  80:	f0 e0       	ldi	r31, 0x00	; 0
  82:	40 e0       	ldi	r20, 0x00	; 0
  84:	17 c0       	rjmp	.+46     	; 0xb4 <__do_clear_bss+0x8>
  86:	b5 91       	lpm	r27, Z+
  88:	a5 91       	lpm	r26, Z+
  8a:	35 91       	lpm	r19, Z+
  8c:	25 91       	lpm	r18, Z+
  8e:	05 91       	lpm	r16, Z+
  90:	07 fd       	sbrc	r16, 7
  92:	0c c0       	rjmp	.+24     	; 0xac <__do_clear_bss>
  94:	95 91       	lpm	r25, Z+
  96:	85 91       	lpm	r24, Z+
  98:	ef 01       	movw	r28, r30
  9a:	f9 2f       	mov	r31, r25
  9c:	e8 2f       	mov	r30, r24
  9e:	05 90       	lpm	r0, Z+
  a0:	0d 92       	st	X+, r0
  a2:	a2 17       	cp	r26, r18
  a4:	b3 07       	cpc	r27, r19
  a6:	d9 f7       	brne	.-10     	; 0x9e <__do_copy_data+0x20>
  a8:	fe 01       	movw	r30, r28
  aa:	04 c0       	rjmp	.+8      	; 0xb4 <__do_clear_bss+0x8>

000000ac <__do_clear_bss>:
  ac:	1d 92       	st	X+, r1
  ae:	a2 17       	cp	r26, r18
  b0:	b3 07       	cpc	r27, r19
  b2:	e1 f7       	brne	.-8      	; 0xac <__do_clear_bss>
  b4:	e1 37       	cpi	r30, 0x71	; 113
  b6:	f4 07       	cpc	r31, r20
  b8:	31 f7       	brne	.-52     	; 0x86 <__do_copy_data+0x8>
  ba:	0e 94 84 03 	call	0x708	; 0x708 <main>
  be:	0c 94 61 00 	jmp	0xc2	; 0xc2 <_exit>

000000c2 <_exit>:
  c2:	f8 94       	cli

000000c4 <__stop_program>:
  c4:	ff cf       	rjmp	.-2      	; 0xc4 <__stop_program>

Disassembly of section .text:

00000b48 <__bad_interrupt>:
 b48:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.cooling_Init:

00000ae4 <cooling_Init>:

#include "cooling_fan.h"

void cooling_Init(void)
{
	GPIO_voidSetPortPinDirection(COOLING_PORT , COOLING_PIN , COOLING_DIR) ;
 ae4:	41 e0       	ldi	r20, 0x01	; 1
 ae6:	67 e0       	ldi	r22, 0x07	; 7
 ae8:	82 e0       	ldi	r24, 0x02	; 2
 aea:	0e 94 63 00 	call	0xc6	; 0xc6 <__data_load_end>
 aee:	08 95       	ret

Disassembly of section .text.cooling_set_state:

000009ec <cooling_set_state>:
}

void cooling_set_state(u8 state)
{
	switch (state)
 9ec:	88 23       	and	r24, r24
 9ee:	41 f0       	breq	.+16     	; 0xa00 <cooling_set_state+0x14>
 9f0:	81 30       	cpi	r24, 0x01	; 1
 9f2:	59 f4       	brne	.+22     	; 0xa0a <cooling_set_state+0x1e>
	{
		case cool_ON :
			GPIO_voidSetPortPinValue(COOLING_PORT , COOLING_PIN , 1) ;
 9f4:	41 e0       	ldi	r20, 0x01	; 1
 9f6:	67 e0       	ldi	r22, 0x07	; 7
 9f8:	82 e0       	ldi	r24, 0x02	; 2
 9fa:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
			break;
 9fe:	08 95       	ret
			
		case cool_OFF :
			GPIO_voidSetPortPinValue(COOLING_PORT , COOLING_PIN , 0) ;
 a00:	40 e0       	ldi	r20, 0x00	; 0
 a02:	67 e0       	ldi	r22, 0x07	; 7
 a04:	82 e0       	ldi	r24, 0x02	; 2
 a06:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
 a0a:	08 95       	ret

Disassembly of section .text.EEPROM_Init:

00000b36 <EEPROM_Init>:

#include "EEPROM.h"

void EEPROM_Init(void)
{
	I2C_Init();
 b36:	0e 94 5a 05 	call	0xab4	; 0xab4 <I2C_Init>
 b3a:	08 95       	ret

Disassembly of section .text.EEPROM_Write:

00000958 <EEPROM_Write>:
}

void EEPROM_Write (u8 data, u8 address)
{
 958:	cf 93       	push	r28
 95a:	df 93       	push	r29
 95c:	c8 2f       	mov	r28, r24
 95e:	d6 2f       	mov	r29, r22
	TWIStart( ) ;
 960:	0e 94 7e 05 	call	0xafc	; 0xafc <TWIStart>
	
	TWIWrite( 0xA0 ) ;				//Write Mode
 964:	80 ea       	ldi	r24, 0xA0	; 160
 966:	0e 94 6b 05 	call	0xad6	; 0xad6 <TWIWrite>
	TWIWrite( address ) ;
 96a:	8d 2f       	mov	r24, r29
 96c:	0e 94 6b 05 	call	0xad6	; 0xad6 <TWIWrite>
	TWIWrite( data ) ;
 970:	8c 2f       	mov	r24, r28
 972:	0e 94 6b 05 	call	0xad6	; 0xad6 <TWIWrite>
	
	TWIStop( ) ;
 976:	0e 94 9e 05 	call	0xb3c	; 0xb3c <TWIStop>
}
 97a:	df 91       	pop	r29
 97c:	cf 91       	pop	r28
 97e:	08 95       	ret

Disassembly of section .text.OFF_STATE:

00000a8a <OFF_STATE>:
	Save_Last_Temp() ;
}
*/
void OFF_STATE(void)
{
	cooling_set_state(cool_OFF) ;
 a8a:	80 e0       	ldi	r24, 0x00	; 0
 a8c:	0e 94 f6 04 	call	0x9ec	; 0x9ec <cooling_set_state>
	heating_set_state(heat_OFF) ;
 a90:	80 e0       	ldi	r24, 0x00	; 0
 a92:	0e 94 16 05 	call	0xa2c	; 0xa2c <heating_set_state>
	SSD_TURN_OFF() ;
 a96:	0e 94 36 05 	call	0xa6c	; 0xa6c <SSD_TURN_OFF>
	LED_OFF() ;
 a9a:	0e 94 8a 05 	call	0xb14	; 0xb14 <LED_OFF>
 a9e:	08 95       	ret

Disassembly of section .text.EXT_voidEnableExtInt:

0000029a <EXT_voidEnableExtInt>:


void EXT_voidEnableExtInt(t_EXT_INT cpy_ext_int , t_TRIGGERING_CONDITION cpy_condition) 
{
	// Enable global interrupts
	sei() ;
 29a:	78 94       	sei
	
	// Enable EXT INT
	switch (cpy_ext_int){
 29c:	81 30       	cpi	r24, 0x01	; 1
 29e:	41 f0       	breq	.+16     	; 0x2b0 <EXT_voidEnableExtInt+0x16>
 2a0:	18 f0       	brcs	.+6      	; 0x2a8 <EXT_voidEnableExtInt+0xe>
 2a2:	82 30       	cpi	r24, 0x02	; 2
 2a4:	49 f0       	breq	.+18     	; 0x2b8 <EXT_voidEnableExtInt+0x1e>
 2a6:	0b c0       	rjmp	.+22     	; 0x2be <EXT_voidEnableExtInt+0x24>
		case EXT_INT_0 :
			SET_BIT(GICR_R , 6) ;
 2a8:	9b b7       	in	r25, 0x3b	; 59
 2aa:	90 64       	ori	r25, 0x40	; 64
 2ac:	9b bf       	out	0x3b, r25	; 59
			break;
 2ae:	07 c0       	rjmp	.+14     	; 0x2be <EXT_voidEnableExtInt+0x24>
			
		case EXT_INT_1 :
			SET_BIT(GICR_R , 7) ;
 2b0:	9b b7       	in	r25, 0x3b	; 59
 2b2:	90 68       	ori	r25, 0x80	; 128
 2b4:	9b bf       	out	0x3b, r25	; 59
			break;
 2b6:	03 c0       	rjmp	.+6      	; 0x2be <EXT_voidEnableExtInt+0x24>
			
		case EXT_INT_2 :
			SET_BIT(GICR_R , 5) ;
 2b8:	9b b7       	in	r25, 0x3b	; 59
 2ba:	90 62       	ori	r25, 0x20	; 32
 2bc:	9b bf       	out	0x3b, r25	; 59
			break;
	}
	
	// Sensing level
	switch (cpy_condition){
 2be:	61 30       	cpi	r22, 0x01	; 1
 2c0:	c1 f0       	breq	.+48     	; 0x2f2 <EXT_voidEnableExtInt+0x58>
 2c2:	28 f0       	brcs	.+10     	; 0x2ce <EXT_voidEnableExtInt+0x34>
 2c4:	62 30       	cpi	r22, 0x02	; 2
 2c6:	31 f1       	breq	.+76     	; 0x314 <EXT_voidEnableExtInt+0x7a>
 2c8:	63 30       	cpi	r22, 0x03	; 3
 2ca:	d1 f1       	breq	.+116    	; 0x340 <EXT_voidEnableExtInt+0xa6>
 2cc:	08 95       	ret
		case LOW_LEVEL :
			if (cpy_ext_int == EXT_INT_0)
 2ce:	81 11       	cpse	r24, r1
 2d0:	06 c0       	rjmp	.+12     	; 0x2de <EXT_voidEnableExtInt+0x44>
			{
				CLEAR_BIT(MCUCR_R , ISC00) ;
 2d2:	95 b7       	in	r25, 0x35	; 53
 2d4:	9e 7f       	andi	r25, 0xFE	; 254
 2d6:	95 bf       	out	0x35, r25	; 53
				CLEAR_BIT(MCUCR_R , ISC01) ;
 2d8:	95 b7       	in	r25, 0x35	; 53
 2da:	9d 7f       	andi	r25, 0xFD	; 253
 2dc:	95 bf       	out	0x35, r25	; 53
			}
			if (cpy_ext_int == EXT_INT_1)
 2de:	81 30       	cpi	r24, 0x01	; 1
 2e0:	09 f0       	breq	.+2      	; 0x2e4 <EXT_voidEnableExtInt+0x4a>
 2e2:	43 c0       	rjmp	.+134    	; 0x36a <EXT_voidEnableExtInt+0xd0>
			{
				CLEAR_BIT(MCUCR_R , ISC10) ;
 2e4:	85 b7       	in	r24, 0x35	; 53
 2e6:	8b 7f       	andi	r24, 0xFB	; 251
 2e8:	85 bf       	out	0x35, r24	; 53
				CLEAR_BIT(MCUCR_R , ISC11) ;
 2ea:	85 b7       	in	r24, 0x35	; 53
 2ec:	87 7f       	andi	r24, 0xF7	; 247
 2ee:	85 bf       	out	0x35, r24	; 53
 2f0:	08 95       	ret
			}
			break;
			
		case ON_CHAGE :
			if (cpy_ext_int == EXT_INT_0)
 2f2:	81 11       	cpse	r24, r1
 2f4:	06 c0       	rjmp	.+12     	; 0x302 <EXT_voidEnableExtInt+0x68>
			{
				SET_BIT(MCUCR_R , ISC00) ;
 2f6:	95 b7       	in	r25, 0x35	; 53
 2f8:	91 60       	ori	r25, 0x01	; 1
 2fa:	95 bf       	out	0x35, r25	; 53
				CLEAR_BIT(MCUCR_R , ISC01) ;
 2fc:	95 b7       	in	r25, 0x35	; 53
 2fe:	9d 7f       	andi	r25, 0xFD	; 253
 300:	95 bf       	out	0x35, r25	; 53
			}
			if (cpy_ext_int == EXT_INT_1)
 302:	81 30       	cpi	r24, 0x01	; 1
 304:	91 f5       	brne	.+100    	; 0x36a <EXT_voidEnableExtInt+0xd0>
			{
				SET_BIT(MCUCR_R , ISC10) ;
 306:	85 b7       	in	r24, 0x35	; 53
 308:	84 60       	ori	r24, 0x04	; 4
 30a:	85 bf       	out	0x35, r24	; 53
				CLEAR_BIT(MCUCR_R , ISC11) ;
 30c:	85 b7       	in	r24, 0x35	; 53
 30e:	87 7f       	andi	r24, 0xF7	; 247
 310:	85 bf       	out	0x35, r24	; 53
 312:	08 95       	ret
			}
			break;
		
		case FALLIN_EDGE :
			if (cpy_ext_int == EXT_INT_0)
 314:	81 11       	cpse	r24, r1
 316:	06 c0       	rjmp	.+12     	; 0x324 <EXT_voidEnableExtInt+0x8a>
			{
				CLEAR_BIT(MCUCR_R , ISC00) ;
 318:	95 b7       	in	r25, 0x35	; 53
 31a:	9e 7f       	andi	r25, 0xFE	; 254
 31c:	95 bf       	out	0x35, r25	; 53
				SET_BIT(MCUCR_R , ISC01) ;
 31e:	95 b7       	in	r25, 0x35	; 53
 320:	92 60       	ori	r25, 0x02	; 2
 322:	95 bf       	out	0x35, r25	; 53
			}
			if (cpy_ext_int == EXT_INT_1)
 324:	81 30       	cpi	r24, 0x01	; 1
 326:	31 f4       	brne	.+12     	; 0x334 <EXT_voidEnableExtInt+0x9a>
			{
				CLEAR_BIT(MCUCR_R , ISC10) ;
 328:	95 b7       	in	r25, 0x35	; 53
 32a:	9b 7f       	andi	r25, 0xFB	; 251
 32c:	95 bf       	out	0x35, r25	; 53
				SET_BIT(MCUCR_R , ISC11) ;
 32e:	95 b7       	in	r25, 0x35	; 53
 330:	98 60       	ori	r25, 0x08	; 8
 332:	95 bf       	out	0x35, r25	; 53
			}
			if (cpy_ext_int == EXT_INT_2)
 334:	82 30       	cpi	r24, 0x02	; 2
 336:	c9 f4       	brne	.+50     	; 0x36a <EXT_voidEnableExtInt+0xd0>
				CLEAR_BIT(MCUCSR_R , MCUCSR_ISC2) ;
 338:	84 b7       	in	r24, 0x34	; 52
 33a:	8f 7b       	andi	r24, 0xBF	; 191
 33c:	84 bf       	out	0x34, r24	; 52
 33e:	08 95       	ret
			break;
		
		case RISIN_EDGE :
			if (cpy_ext_int == EXT_INT_0)
 340:	81 11       	cpse	r24, r1
 342:	06 c0       	rjmp	.+12     	; 0x350 <EXT_voidEnableExtInt+0xb6>
			{
				SET_BIT(MCUCR_R , ISC00) ;
 344:	95 b7       	in	r25, 0x35	; 53
 346:	91 60       	ori	r25, 0x01	; 1
 348:	95 bf       	out	0x35, r25	; 53
				SET_BIT(MCUCR_R , ISC01) ;
 34a:	95 b7       	in	r25, 0x35	; 53
 34c:	92 60       	ori	r25, 0x02	; 2
 34e:	95 bf       	out	0x35, r25	; 53
			}
			if (cpy_ext_int == EXT_INT_1)
 350:	81 30       	cpi	r24, 0x01	; 1
 352:	31 f4       	brne	.+12     	; 0x360 <EXT_voidEnableExtInt+0xc6>
			{
				SET_BIT(MCUCR_R , ISC10) ;
 354:	95 b7       	in	r25, 0x35	; 53
 356:	94 60       	ori	r25, 0x04	; 4
 358:	95 bf       	out	0x35, r25	; 53
				SET_BIT(MCUCR_R , ISC11) ;
 35a:	95 b7       	in	r25, 0x35	; 53
 35c:	98 60       	ori	r25, 0x08	; 8
 35e:	95 bf       	out	0x35, r25	; 53
			}
			if (cpy_ext_int == EXT_INT_2)
 360:	82 30       	cpi	r24, 0x02	; 2
 362:	19 f4       	brne	.+6      	; 0x36a <EXT_voidEnableExtInt+0xd0>
				SET_BIT(MCUCSR_R , MCUCSR_ISC2) ;
 364:	84 b7       	in	r24, 0x34	; 52
 366:	80 64       	ori	r24, 0x40	; 64
 368:	84 bf       	out	0x34, r24	; 52
 36a:	08 95       	ret

Disassembly of section .text.GPIO_voidSetPortDirection:

0000082e <GPIO_voidSetPortDirection>:
			
		default: break;
	}
	
	return local_u8retval ;
}
 82e:	81 30       	cpi	r24, 0x01	; 1
 830:	79 f0       	breq	.+30     	; 0x850 <GPIO_voidSetPortDirection+0x22>
 832:	28 f0       	brcs	.+10     	; 0x83e <GPIO_voidSetPortDirection+0x10>
 834:	82 30       	cpi	r24, 0x02	; 2
 836:	a9 f0       	breq	.+42     	; 0x862 <__stack+0x3>
 838:	83 30       	cpi	r24, 0x03	; 3
 83a:	e1 f0       	breq	.+56     	; 0x874 <__stack+0x15>
 83c:	08 95       	ret
 83e:	61 30       	cpi	r22, 0x01	; 1
 840:	19 f4       	brne	.+6      	; 0x848 <GPIO_voidSetPortDirection+0x1a>
 842:	8f ef       	ldi	r24, 0xFF	; 255
 844:	8a bb       	out	0x1a, r24	; 26
 846:	08 95       	ret
 848:	61 11       	cpse	r22, r1
 84a:	1c c0       	rjmp	.+56     	; 0x884 <__stack+0x25>
 84c:	1a ba       	out	0x1a, r1	; 26
 84e:	08 95       	ret
 850:	61 30       	cpi	r22, 0x01	; 1
 852:	19 f4       	brne	.+6      	; 0x85a <GPIO_voidSetPortDirection+0x2c>
 854:	8f ef       	ldi	r24, 0xFF	; 255
 856:	87 bb       	out	0x17, r24	; 23
 858:	08 95       	ret
 85a:	61 11       	cpse	r22, r1
 85c:	13 c0       	rjmp	.+38     	; 0x884 <__stack+0x25>
 85e:	17 ba       	out	0x17, r1	; 23
 860:	08 95       	ret
 862:	61 30       	cpi	r22, 0x01	; 1
 864:	19 f4       	brne	.+6      	; 0x86c <__stack+0xd>
 866:	8f ef       	ldi	r24, 0xFF	; 255
 868:	84 bb       	out	0x14, r24	; 20
 86a:	08 95       	ret
 86c:	61 11       	cpse	r22, r1
 86e:	0a c0       	rjmp	.+20     	; 0x884 <__stack+0x25>
 870:	14 ba       	out	0x14, r1	; 20
 872:	08 95       	ret
 874:	61 30       	cpi	r22, 0x01	; 1
 876:	19 f4       	brne	.+6      	; 0x87e <__stack+0x1f>
 878:	8f ef       	ldi	r24, 0xFF	; 255
 87a:	81 bb       	out	0x11, r24	; 17
 87c:	08 95       	ret
 87e:	61 11       	cpse	r22, r1
 880:	01 c0       	rjmp	.+2      	; 0x884 <__stack+0x25>
 882:	11 ba       	out	0x11, r1	; 17
 884:	08 95       	ret

Disassembly of section .text.GPIO_voidSetPortPinDirection:

000000c6 <GPIO_voidSetPortPinDirection>:
  c6:	81 30       	cpi	r24, 0x01	; 1
  c8:	11 f1       	breq	.+68     	; 0x10e <GPIO_voidSetPortPinDirection+0x48>
  ca:	30 f0       	brcs	.+12     	; 0xd8 <GPIO_voidSetPortPinDirection+0x12>
  cc:	82 30       	cpi	r24, 0x02	; 2
  ce:	d1 f1       	breq	.+116    	; 0x144 <GPIO_voidSetPortPinDirection+0x7e>
  d0:	83 30       	cpi	r24, 0x03	; 3
  d2:	09 f4       	brne	.+2      	; 0xd6 <GPIO_voidSetPortPinDirection+0x10>
  d4:	52 c0       	rjmp	.+164    	; 0x17a <GPIO_voidSetPortPinDirection+0xb4>
  d6:	08 95       	ret
  d8:	41 30       	cpi	r20, 0x01	; 1
  da:	59 f4       	brne	.+22     	; 0xf2 <GPIO_voidSetPortPinDirection+0x2c>
  dc:	2a b3       	in	r18, 0x1a	; 26
  de:	81 e0       	ldi	r24, 0x01	; 1
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	02 c0       	rjmp	.+4      	; 0xe8 <GPIO_voidSetPortPinDirection+0x22>
  e4:	88 0f       	add	r24, r24
  e6:	99 1f       	adc	r25, r25
  e8:	6a 95       	dec	r22
  ea:	e2 f7       	brpl	.-8      	; 0xe4 <GPIO_voidSetPortPinDirection+0x1e>
  ec:	82 2b       	or	r24, r18
  ee:	8a bb       	out	0x1a, r24	; 26
  f0:	08 95       	ret
  f2:	41 11       	cpse	r20, r1
  f4:	5c c0       	rjmp	.+184    	; 0x1ae <GPIO_voidSetPortPinDirection+0xe8>
  f6:	2a b3       	in	r18, 0x1a	; 26
  f8:	81 e0       	ldi	r24, 0x01	; 1
  fa:	90 e0       	ldi	r25, 0x00	; 0
  fc:	02 c0       	rjmp	.+4      	; 0x102 <GPIO_voidSetPortPinDirection+0x3c>
  fe:	88 0f       	add	r24, r24
 100:	99 1f       	adc	r25, r25
 102:	6a 95       	dec	r22
 104:	e2 f7       	brpl	.-8      	; 0xfe <GPIO_voidSetPortPinDirection+0x38>
 106:	80 95       	com	r24
 108:	82 23       	and	r24, r18
 10a:	8a bb       	out	0x1a, r24	; 26
 10c:	08 95       	ret
 10e:	41 30       	cpi	r20, 0x01	; 1
 110:	59 f4       	brne	.+22     	; 0x128 <GPIO_voidSetPortPinDirection+0x62>
 112:	27 b3       	in	r18, 0x17	; 23
 114:	81 e0       	ldi	r24, 0x01	; 1
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	02 c0       	rjmp	.+4      	; 0x11e <GPIO_voidSetPortPinDirection+0x58>
 11a:	88 0f       	add	r24, r24
 11c:	99 1f       	adc	r25, r25
 11e:	6a 95       	dec	r22
 120:	e2 f7       	brpl	.-8      	; 0x11a <GPIO_voidSetPortPinDirection+0x54>
 122:	82 2b       	or	r24, r18
 124:	87 bb       	out	0x17, r24	; 23
 126:	08 95       	ret
 128:	41 11       	cpse	r20, r1
 12a:	41 c0       	rjmp	.+130    	; 0x1ae <GPIO_voidSetPortPinDirection+0xe8>
 12c:	27 b3       	in	r18, 0x17	; 23
 12e:	81 e0       	ldi	r24, 0x01	; 1
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	02 c0       	rjmp	.+4      	; 0x138 <GPIO_voidSetPortPinDirection+0x72>
 134:	88 0f       	add	r24, r24
 136:	99 1f       	adc	r25, r25
 138:	6a 95       	dec	r22
 13a:	e2 f7       	brpl	.-8      	; 0x134 <GPIO_voidSetPortPinDirection+0x6e>
 13c:	80 95       	com	r24
 13e:	82 23       	and	r24, r18
 140:	87 bb       	out	0x17, r24	; 23
 142:	08 95       	ret
 144:	41 30       	cpi	r20, 0x01	; 1
 146:	59 f4       	brne	.+22     	; 0x15e <GPIO_voidSetPortPinDirection+0x98>
 148:	24 b3       	in	r18, 0x14	; 20
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	02 c0       	rjmp	.+4      	; 0x154 <GPIO_voidSetPortPinDirection+0x8e>
 150:	88 0f       	add	r24, r24
 152:	99 1f       	adc	r25, r25
 154:	6a 95       	dec	r22
 156:	e2 f7       	brpl	.-8      	; 0x150 <GPIO_voidSetPortPinDirection+0x8a>
 158:	82 2b       	or	r24, r18
 15a:	84 bb       	out	0x14, r24	; 20
 15c:	08 95       	ret
 15e:	41 11       	cpse	r20, r1
 160:	26 c0       	rjmp	.+76     	; 0x1ae <GPIO_voidSetPortPinDirection+0xe8>
 162:	24 b3       	in	r18, 0x14	; 20
 164:	81 e0       	ldi	r24, 0x01	; 1
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	02 c0       	rjmp	.+4      	; 0x16e <GPIO_voidSetPortPinDirection+0xa8>
 16a:	88 0f       	add	r24, r24
 16c:	99 1f       	adc	r25, r25
 16e:	6a 95       	dec	r22
 170:	e2 f7       	brpl	.-8      	; 0x16a <GPIO_voidSetPortPinDirection+0xa4>
 172:	80 95       	com	r24
 174:	82 23       	and	r24, r18
 176:	84 bb       	out	0x14, r24	; 20
 178:	08 95       	ret
 17a:	41 30       	cpi	r20, 0x01	; 1
 17c:	59 f4       	brne	.+22     	; 0x194 <GPIO_voidSetPortPinDirection+0xce>
 17e:	21 b3       	in	r18, 0x11	; 17
 180:	81 e0       	ldi	r24, 0x01	; 1
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	02 c0       	rjmp	.+4      	; 0x18a <GPIO_voidSetPortPinDirection+0xc4>
 186:	88 0f       	add	r24, r24
 188:	99 1f       	adc	r25, r25
 18a:	6a 95       	dec	r22
 18c:	e2 f7       	brpl	.-8      	; 0x186 <GPIO_voidSetPortPinDirection+0xc0>
 18e:	82 2b       	or	r24, r18
 190:	81 bb       	out	0x11, r24	; 17
 192:	08 95       	ret
 194:	41 11       	cpse	r20, r1
 196:	0b c0       	rjmp	.+22     	; 0x1ae <GPIO_voidSetPortPinDirection+0xe8>
 198:	21 b3       	in	r18, 0x11	; 17
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	90 e0       	ldi	r25, 0x00	; 0
 19e:	02 c0       	rjmp	.+4      	; 0x1a4 <GPIO_voidSetPortPinDirection+0xde>
 1a0:	88 0f       	add	r24, r24
 1a2:	99 1f       	adc	r25, r25
 1a4:	6a 95       	dec	r22
 1a6:	e2 f7       	brpl	.-8      	; 0x1a0 <GPIO_voidSetPortPinDirection+0xda>
 1a8:	80 95       	com	r24
 1aa:	82 23       	and	r24, r18
 1ac:	81 bb       	out	0x11, r24	; 17
 1ae:	08 95       	ret

Disassembly of section .text.GPIO_voidSetPortPinValue:

000001b0 <GPIO_voidSetPortPinValue>:
 1b0:	81 30       	cpi	r24, 0x01	; 1
 1b2:	11 f1       	breq	.+68     	; 0x1f8 <GPIO_voidSetPortPinValue+0x48>
 1b4:	30 f0       	brcs	.+12     	; 0x1c2 <GPIO_voidSetPortPinValue+0x12>
 1b6:	82 30       	cpi	r24, 0x02	; 2
 1b8:	d1 f1       	breq	.+116    	; 0x22e <GPIO_voidSetPortPinValue+0x7e>
 1ba:	83 30       	cpi	r24, 0x03	; 3
 1bc:	09 f4       	brne	.+2      	; 0x1c0 <GPIO_voidSetPortPinValue+0x10>
 1be:	52 c0       	rjmp	.+164    	; 0x264 <GPIO_voidSetPortPinValue+0xb4>
 1c0:	08 95       	ret
 1c2:	41 30       	cpi	r20, 0x01	; 1
 1c4:	59 f4       	brne	.+22     	; 0x1dc <GPIO_voidSetPortPinValue+0x2c>
 1c6:	2b b3       	in	r18, 0x1b	; 27
 1c8:	81 e0       	ldi	r24, 0x01	; 1
 1ca:	90 e0       	ldi	r25, 0x00	; 0
 1cc:	02 c0       	rjmp	.+4      	; 0x1d2 <GPIO_voidSetPortPinValue+0x22>
 1ce:	88 0f       	add	r24, r24
 1d0:	99 1f       	adc	r25, r25
 1d2:	6a 95       	dec	r22
 1d4:	e2 f7       	brpl	.-8      	; 0x1ce <GPIO_voidSetPortPinValue+0x1e>
 1d6:	82 2b       	or	r24, r18
 1d8:	8b bb       	out	0x1b, r24	; 27
 1da:	08 95       	ret
 1dc:	41 11       	cpse	r20, r1
 1de:	5c c0       	rjmp	.+184    	; 0x298 <GPIO_voidSetPortPinValue+0xe8>
 1e0:	2b b3       	in	r18, 0x1b	; 27
 1e2:	81 e0       	ldi	r24, 0x01	; 1
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	02 c0       	rjmp	.+4      	; 0x1ec <GPIO_voidSetPortPinValue+0x3c>
 1e8:	88 0f       	add	r24, r24
 1ea:	99 1f       	adc	r25, r25
 1ec:	6a 95       	dec	r22
 1ee:	e2 f7       	brpl	.-8      	; 0x1e8 <GPIO_voidSetPortPinValue+0x38>
 1f0:	80 95       	com	r24
 1f2:	82 23       	and	r24, r18
 1f4:	8b bb       	out	0x1b, r24	; 27
 1f6:	08 95       	ret
 1f8:	41 30       	cpi	r20, 0x01	; 1
 1fa:	59 f4       	brne	.+22     	; 0x212 <GPIO_voidSetPortPinValue+0x62>
 1fc:	28 b3       	in	r18, 0x18	; 24
 1fe:	81 e0       	ldi	r24, 0x01	; 1
 200:	90 e0       	ldi	r25, 0x00	; 0
 202:	02 c0       	rjmp	.+4      	; 0x208 <GPIO_voidSetPortPinValue+0x58>
 204:	88 0f       	add	r24, r24
 206:	99 1f       	adc	r25, r25
 208:	6a 95       	dec	r22
 20a:	e2 f7       	brpl	.-8      	; 0x204 <GPIO_voidSetPortPinValue+0x54>
 20c:	82 2b       	or	r24, r18
 20e:	88 bb       	out	0x18, r24	; 24
 210:	08 95       	ret
 212:	41 11       	cpse	r20, r1
 214:	41 c0       	rjmp	.+130    	; 0x298 <GPIO_voidSetPortPinValue+0xe8>
 216:	28 b3       	in	r18, 0x18	; 24
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	90 e0       	ldi	r25, 0x00	; 0
 21c:	02 c0       	rjmp	.+4      	; 0x222 <GPIO_voidSetPortPinValue+0x72>
 21e:	88 0f       	add	r24, r24
 220:	99 1f       	adc	r25, r25
 222:	6a 95       	dec	r22
 224:	e2 f7       	brpl	.-8      	; 0x21e <GPIO_voidSetPortPinValue+0x6e>
 226:	80 95       	com	r24
 228:	82 23       	and	r24, r18
 22a:	88 bb       	out	0x18, r24	; 24
 22c:	08 95       	ret
 22e:	41 30       	cpi	r20, 0x01	; 1
 230:	59 f4       	brne	.+22     	; 0x248 <GPIO_voidSetPortPinValue+0x98>
 232:	25 b3       	in	r18, 0x15	; 21
 234:	81 e0       	ldi	r24, 0x01	; 1
 236:	90 e0       	ldi	r25, 0x00	; 0
 238:	02 c0       	rjmp	.+4      	; 0x23e <GPIO_voidSetPortPinValue+0x8e>
 23a:	88 0f       	add	r24, r24
 23c:	99 1f       	adc	r25, r25
 23e:	6a 95       	dec	r22
 240:	e2 f7       	brpl	.-8      	; 0x23a <GPIO_voidSetPortPinValue+0x8a>
 242:	82 2b       	or	r24, r18
 244:	85 bb       	out	0x15, r24	; 21
 246:	08 95       	ret
 248:	41 11       	cpse	r20, r1
 24a:	26 c0       	rjmp	.+76     	; 0x298 <GPIO_voidSetPortPinValue+0xe8>
 24c:	25 b3       	in	r18, 0x15	; 21
 24e:	81 e0       	ldi	r24, 0x01	; 1
 250:	90 e0       	ldi	r25, 0x00	; 0
 252:	02 c0       	rjmp	.+4      	; 0x258 <GPIO_voidSetPortPinValue+0xa8>
 254:	88 0f       	add	r24, r24
 256:	99 1f       	adc	r25, r25
 258:	6a 95       	dec	r22
 25a:	e2 f7       	brpl	.-8      	; 0x254 <GPIO_voidSetPortPinValue+0xa4>
 25c:	80 95       	com	r24
 25e:	82 23       	and	r24, r18
 260:	85 bb       	out	0x15, r24	; 21
 262:	08 95       	ret
 264:	41 30       	cpi	r20, 0x01	; 1
 266:	59 f4       	brne	.+22     	; 0x27e <GPIO_voidSetPortPinValue+0xce>
 268:	22 b3       	in	r18, 0x12	; 18
 26a:	81 e0       	ldi	r24, 0x01	; 1
 26c:	90 e0       	ldi	r25, 0x00	; 0
 26e:	02 c0       	rjmp	.+4      	; 0x274 <GPIO_voidSetPortPinValue+0xc4>
 270:	88 0f       	add	r24, r24
 272:	99 1f       	adc	r25, r25
 274:	6a 95       	dec	r22
 276:	e2 f7       	brpl	.-8      	; 0x270 <GPIO_voidSetPortPinValue+0xc0>
 278:	82 2b       	or	r24, r18
 27a:	82 bb       	out	0x12, r24	; 18
 27c:	08 95       	ret
 27e:	41 11       	cpse	r20, r1
 280:	0b c0       	rjmp	.+22     	; 0x298 <GPIO_voidSetPortPinValue+0xe8>
 282:	22 b3       	in	r18, 0x12	; 18
 284:	81 e0       	ldi	r24, 0x01	; 1
 286:	90 e0       	ldi	r25, 0x00	; 0
 288:	02 c0       	rjmp	.+4      	; 0x28e <GPIO_voidSetPortPinValue+0xde>
 28a:	88 0f       	add	r24, r24
 28c:	99 1f       	adc	r25, r25
 28e:	6a 95       	dec	r22
 290:	e2 f7       	brpl	.-8      	; 0x28a <GPIO_voidSetPortPinValue+0xda>
 292:	80 95       	com	r24
 294:	82 23       	and	r24, r18
 296:	82 bb       	out	0x12, r24	; 18
 298:	08 95       	ret

Disassembly of section .text.GPIO_voidSetPortValue:

00000a0c <GPIO_voidSetPortValue>:
	}
}

void GPIO_voidSetPortValue(u8 cpy_PORT , u8 cpy_value)
{
	switch( cpy_PORT ){
 a0c:	81 30       	cpi	r24, 0x01	; 1
 a0e:	41 f0       	breq	.+16     	; 0xa20 <GPIO_voidSetPortValue+0x14>
 a10:	28 f0       	brcs	.+10     	; 0xa1c <GPIO_voidSetPortValue+0x10>
 a12:	82 30       	cpi	r24, 0x02	; 2
 a14:	39 f0       	breq	.+14     	; 0xa24 <GPIO_voidSetPortValue+0x18>
 a16:	83 30       	cpi	r24, 0x03	; 3
 a18:	39 f0       	breq	.+14     	; 0xa28 <GPIO_voidSetPortValue+0x1c>
 a1a:	08 95       	ret
		case PORT_A :
			PORTA_R = cpy_value ;
 a1c:	6b bb       	out	0x1b, r22	; 27
			break;
 a1e:	08 95       	ret
		
		case PORT_B :
			PORTB_R = cpy_value ;
 a20:	68 bb       	out	0x18, r22	; 24
			break;
 a22:	08 95       	ret
			
		case PORT_C :
			PORTC_R = cpy_value ;
 a24:	65 bb       	out	0x15, r22	; 21
			break;
 a26:	08 95       	ret
			
		case PORT_D :
			PORTD_R = cpy_value ;
 a28:	62 bb       	out	0x12, r22	; 18
 a2a:	08 95       	ret

Disassembly of section .text.GPIO_voidTogglePortPinValue:

00000638 <GPIO_voidTogglePortPinValue>:
			
		default: break;
	}
	
	return local_u8retval ;
}
 638:	81 30       	cpi	r24, 0x01	; 1
 63a:	89 f0       	breq	.+34     	; 0x65e <GPIO_voidTogglePortPinValue+0x26>
 63c:	28 f0       	brcs	.+10     	; 0x648 <GPIO_voidTogglePortPinValue+0x10>
 63e:	82 30       	cpi	r24, 0x02	; 2
 640:	c9 f0       	breq	.+50     	; 0x674 <GPIO_voidTogglePortPinValue+0x3c>
 642:	83 30       	cpi	r24, 0x03	; 3
 644:	11 f1       	breq	.+68     	; 0x68a <GPIO_voidTogglePortPinValue+0x52>
 646:	08 95       	ret
 648:	2b b3       	in	r18, 0x1b	; 27
 64a:	81 e0       	ldi	r24, 0x01	; 1
 64c:	90 e0       	ldi	r25, 0x00	; 0
 64e:	02 c0       	rjmp	.+4      	; 0x654 <GPIO_voidTogglePortPinValue+0x1c>
 650:	88 0f       	add	r24, r24
 652:	99 1f       	adc	r25, r25
 654:	6a 95       	dec	r22
 656:	e2 f7       	brpl	.-8      	; 0x650 <GPIO_voidTogglePortPinValue+0x18>
 658:	82 27       	eor	r24, r18
 65a:	8b bb       	out	0x1b, r24	; 27
 65c:	08 95       	ret
 65e:	28 b3       	in	r18, 0x18	; 24
 660:	81 e0       	ldi	r24, 0x01	; 1
 662:	90 e0       	ldi	r25, 0x00	; 0
 664:	02 c0       	rjmp	.+4      	; 0x66a <GPIO_voidTogglePortPinValue+0x32>
 666:	88 0f       	add	r24, r24
 668:	99 1f       	adc	r25, r25
 66a:	6a 95       	dec	r22
 66c:	e2 f7       	brpl	.-8      	; 0x666 <GPIO_voidTogglePortPinValue+0x2e>
 66e:	82 27       	eor	r24, r18
 670:	88 bb       	out	0x18, r24	; 24
 672:	08 95       	ret
 674:	25 b3       	in	r18, 0x15	; 21
 676:	81 e0       	ldi	r24, 0x01	; 1
 678:	90 e0       	ldi	r25, 0x00	; 0
 67a:	02 c0       	rjmp	.+4      	; 0x680 <GPIO_voidTogglePortPinValue+0x48>
 67c:	88 0f       	add	r24, r24
 67e:	99 1f       	adc	r25, r25
 680:	6a 95       	dec	r22
 682:	e2 f7       	brpl	.-8      	; 0x67c <GPIO_voidTogglePortPinValue+0x44>
 684:	82 27       	eor	r24, r18
 686:	85 bb       	out	0x15, r24	; 21
 688:	08 95       	ret
 68a:	22 b3       	in	r18, 0x12	; 18
 68c:	81 e0       	ldi	r24, 0x01	; 1
 68e:	90 e0       	ldi	r25, 0x00	; 0
 690:	02 c0       	rjmp	.+4      	; 0x696 <GPIO_voidTogglePortPinValue+0x5e>
 692:	88 0f       	add	r24, r24
 694:	99 1f       	adc	r25, r25
 696:	6a 95       	dec	r22
 698:	e2 f7       	brpl	.-8      	; 0x692 <GPIO_voidTogglePortPinValue+0x5a>
 69a:	82 27       	eor	r24, r18
 69c:	82 bb       	out	0x12, r24	; 18
 69e:	08 95       	ret

Disassembly of section .text.GPIO_u8GetPortValue:

000009a6 <GPIO_u8GetPortValue>:

u8 GPIO_u8GetPortValue(u8 cpy_PORT)
{
	u8 local_u8retval = 0 ;
	
	switch ( cpy_PORT ){
 9a6:	81 30       	cpi	r24, 0x01	; 1
 9a8:	41 f0       	breq	.+16     	; 0x9ba <GPIO_u8GetPortValue+0x14>
 9aa:	28 f0       	brcs	.+10     	; 0x9b6 <GPIO_u8GetPortValue+0x10>
 9ac:	82 30       	cpi	r24, 0x02	; 2
 9ae:	39 f0       	breq	.+14     	; 0x9be <GPIO_u8GetPortValue+0x18>
 9b0:	83 30       	cpi	r24, 0x03	; 3
 9b2:	39 f0       	breq	.+14     	; 0x9c2 <GPIO_u8GetPortValue+0x1c>
 9b4:	08 c0       	rjmp	.+16     	; 0x9c6 <GPIO_u8GetPortValue+0x20>
		case PORT_A :
			local_u8retval = PINA_R ;
 9b6:	89 b3       	in	r24, 0x19	; 25
			break;
 9b8:	08 95       	ret
		
		case PORT_B :
			local_u8retval = PINB_R ;
 9ba:	86 b3       	in	r24, 0x16	; 22
			break;
 9bc:	08 95       	ret
			
		case PORT_C :
			local_u8retval = PINC_R ;
 9be:	83 b3       	in	r24, 0x13	; 19
			break;
 9c0:	08 95       	ret
			
		case PORT_D :
			local_u8retval = PIND_R ;
 9c2:	80 b3       	in	r24, 0x10	; 16
			break;
 9c4:	08 95       	ret
	return local_u8retval ;
}

u8 GPIO_u8GetPortValue(u8 cpy_PORT)
{
	u8 local_u8retval = 0 ;
 9c6:	80 e0       	ldi	r24, 0x00	; 0
			
		default: break;
	}
	
	return local_u8retval ;
 9c8:	08 95       	ret

Disassembly of section .text.heating_Init:

00000af0 <heating_Init>:

#include "heating_element.h"

void heating_Init(void)
{
	GPIO_voidSetPortPinDirection(HEATING_PORT , HEATING_PIN , HEATING_DIR) ;
 af0:	41 e0       	ldi	r20, 0x01	; 1
 af2:	66 e0       	ldi	r22, 0x06	; 6
 af4:	82 e0       	ldi	r24, 0x02	; 2
 af6:	0e 94 63 00 	call	0xc6	; 0xc6 <__data_load_end>
 afa:	08 95       	ret

Disassembly of section .text.heating_set_state:

00000a2c <heating_set_state>:
}

void heating_set_state(u8 state)
{
	switch (state)
 a2c:	88 23       	and	r24, r24
 a2e:	41 f0       	breq	.+16     	; 0xa40 <heating_set_state+0x14>
 a30:	81 30       	cpi	r24, 0x01	; 1
 a32:	59 f4       	brne	.+22     	; 0xa4a <heating_set_state+0x1e>
	{
		case heat_ON :
		GPIO_voidSetPortPinValue(HEATING_PORT , HEATING_PIN , 1) ;
 a34:	41 e0       	ldi	r20, 0x01	; 1
 a36:	66 e0       	ldi	r22, 0x06	; 6
 a38:	82 e0       	ldi	r24, 0x02	; 2
 a3a:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
		break;
 a3e:	08 95       	ret
		
		case heat_OFF :
		GPIO_voidSetPortPinValue(HEATING_PORT , HEATING_PIN , 0) ;
 a40:	40 e0       	ldi	r20, 0x00	; 0
 a42:	66 e0       	ldi	r22, 0x06	; 6
 a44:	82 e0       	ldi	r24, 0x02	; 2
 a46:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
 a4a:	08 95       	ret

Disassembly of section .text.I2C_Init:

00000ab4 <I2C_Init>:

void I2C_Init(void)
{
  // TWI initialization
  // Bit Rate: 400.000 kHz
  TWBR = 72;
 ab4:	88 e4       	ldi	r24, 0x48	; 72
 ab6:	80 b9       	out	0x00, r24	; 0
  // Generate Acknowledge Pulse: On
  // TWI Interrupt: Off
  TWCR = 0x44;
 ab8:	84 e4       	ldi	r24, 0x44	; 68
 aba:	86 bf       	out	0x36, r24	; 54
  TWSR = 0x00;
 abc:	11 b8       	out	0x01, r1	; 1
  TWSR &= (~((1 << TWPS1) | (1 << TWPS0)));
 abe:	81 b1       	in	r24, 0x01	; 1
 ac0:	8c 7f       	andi	r24, 0xFC	; 252
 ac2:	81 b9       	out	0x01, r24	; 1
 ac4:	08 95       	ret

Disassembly of section .text.TWIStart:

00000afc <TWIStart>:

void TWIStart(void)
{

  // Send Start Condition
  TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
 afc:	84 ea       	ldi	r24, 0xA4	; 164
 afe:	86 bf       	out	0x36, r24	; 54

  // Wait for TWINT flag set in TWCR Register
  while (!(TWCR & (1 << TWINT)))
 b00:	06 b6       	in	r0, 0x36	; 54
 b02:	07 fe       	sbrs	r0, 7
 b04:	fd cf       	rjmp	.-6      	; 0xb00 <TWIStart+0x4>
    ;
}
 b06:	08 95       	ret

Disassembly of section .text.TWIStop:

00000b3c <TWIStop>:

void TWIStop(void)
{
  // Send Stop Condition
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
 b3c:	84 e9       	ldi	r24, 0x94	; 148
 b3e:	86 bf       	out	0x36, r24	; 54
 b40:	08 95       	ret

Disassembly of section .text.TWIWrite:

00000ad6 <TWIWrite>:
}

void TWIWrite(u8 data)
{
  // Put data On TWI Register
  TWDR = data;
 ad6:	83 b9       	out	0x03, r24	; 3
  // Send Data
  TWCR = (1 << TWINT) | (1 << TWEN);
 ad8:	84 e8       	ldi	r24, 0x84	; 132
 ada:	86 bf       	out	0x36, r24	; 54
  // Wait for TWINT flag set in TWCR Register
  while (!(TWCR & (1 << TWINT)))
 adc:	06 b6       	in	r0, 0x36	; 54
 ade:	07 fe       	sbrs	r0, 7
 ae0:	fd cf       	rjmp	.-6      	; 0xadc <TWIWrite+0x6>
    ;
}
 ae2:	08 95       	ret

Disassembly of section .text.LED_ON:

00000b08 <LED_ON>:
	LED_OFF() ;
}

void LED_ON(void)
{
	GPIO_voidSetPortPinValue(LED_PORT , LED_PIN , 1) ;
 b08:	41 e0       	ldi	r20, 0x01	; 1
 b0a:	67 e0       	ldi	r22, 0x07	; 7
 b0c:	81 e0       	ldi	r24, 0x01	; 1
 b0e:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
 b12:	08 95       	ret

Disassembly of section .text.LED_OFF:

00000b14 <LED_OFF>:
}

void LED_OFF(void)
{
	GPIO_voidSetPortPinValue(LED_PORT , LED_PIN , 0) ;
 b14:	40 e0       	ldi	r20, 0x00	; 0
 b16:	67 e0       	ldi	r22, 0x07	; 7
 b18:	81 e0       	ldi	r24, 0x01	; 1
 b1a:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
 b1e:	08 95       	ret

Disassembly of section .text.LED_Init:

00000ac6 <LED_Init>:
#include "LED.h"


void LED_Init(void)
{
	GPIO_voidSetPortPinDirection(LED_PORT , LED_PIN , LED_DIRECTION) ;
 ac6:	41 e0       	ldi	r20, 0x01	; 1
 ac8:	67 e0       	ldi	r22, 0x07	; 7
 aca:	81 e0       	ldi	r24, 0x01	; 1
 acc:	0e 94 63 00 	call	0xc6	; 0xc6 <__data_load_end>
	
	//Turn OFF the led as the initial state
	LED_OFF() ;
 ad0:	0e 94 8a 05 	call	0xb14	; 0xb14 <LED_OFF>
 ad4:	08 95       	ret

Disassembly of section .text.LED_Blink:

00000b2c <LED_Blink>:
	GPIO_voidSetPortPinValue(LED_PORT , LED_PIN , 0) ;
}

void LED_Blink(void)
{
	GPIO_voidTogglePortPinValue(LED_PORT , LED_PIN) ;
 b2c:	67 e0       	ldi	r22, 0x07	; 7
 b2e:	81 e0       	ldi	r24, 0x01	; 1
 b30:	0e 94 1c 03 	call	0x638	; 0x638 <GPIO_voidTogglePortPinValue>
 b34:	08 95       	ret

Disassembly of section .text.Save_Last_Temp:

00000b20 <Save_Last_Temp>:
	}
}

void Save_Last_Temp(void)
{
	EEPROM_Write(sensed_temp , ADDRESS) ;
 b20:	60 e0       	ldi	r22, 0x00	; 0
 b22:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 b26:	0e 94 ac 04 	call	0x958	; 0x958 <EEPROM_Write>
 b2a:	08 95       	ret

Disassembly of section .text.main:

00000708 <main>:



int main(void)
{
	current_state = HEATER_OFF ;
 708:	10 92 9f 00 	sts	0x009F, r1	; 0x80009f <current_state>

	LED_Init() ;
 70c:	0e 94 63 05 	call	0xac6	; 0xac6 <LED_Init>
	SW_Init() ;
 710:	0e 94 8a 04 	call	0x914	; 0x914 <SW_Init>
	SSD_Init() ;
 714:	0e 94 e5 04 	call	0x9ca	; 0x9ca <SSD_Init>
	//LM35_Init() ;
	EEPROM_Init() ;
 718:	0e 94 9b 05 	call	0xb36	; 0xb36 <EEPROM_Init>
	cooling_Init() ;
 71c:	0e 94 72 05 	call	0xae4	; 0xae4 <cooling_Init>
	heating_Init() ;
 720:	0e 94 78 05 	call	0xaf0	; 0xaf0 <heating_Init>
	
	EXT_voidEnableExtInt(EXT_INT_2 , FALLIN_EDGE) ;
 724:	62 e0       	ldi	r22, 0x02	; 2
 726:	82 e0       	ldi	r24, 0x02	; 2
 728:	0e 94 4d 01 	call	0x29a	; 0x29a <EXT_voidEnableExtInt>
	
	SCH_Init_T1() ;
 72c:	0e 94 67 04 	call	0x8ce	; 0x8ce <SCH_Init_T1>
	
	SCH_Add_Task(SW_ST , 0 , SW_PERIOD) ;
 730:	44 e6       	ldi	r20, 0x64	; 100
 732:	60 e0       	ldi	r22, 0x00	; 0
 734:	86 eb       	ldi	r24, 0xB6	; 182
 736:	91 e0       	ldi	r25, 0x01	; 1
 738:	0e 94 50 03 	call	0x6a0	; 0x6a0 <SCH_Add_Task>
	//SCH_Add_Task(LM35_Read_Temp , 0 , TEMPERATURE_period) ;
	SCH_Add_Task(Heat_Cool_Elements , 0 , SYSTEM_PERIOD) ;
 73c:	44 e1       	ldi	r20, 0x14	; 20
 73e:	60 e0       	ldi	r22, 0x00	; 0
 740:	8f ea       	ldi	r24, 0xAF	; 175
 742:	92 e0       	ldi	r25, 0x02	; 2
 744:	0e 94 50 03 	call	0x6a0	; 0x6a0 <SCH_Add_Task>
	SCH_Add_Task(SSD_UPDATE , 0 , SYSTEM_PERIOD) ;
 748:	44 e1       	ldi	r20, 0x14	; 20
 74a:	60 e0       	ldi	r22, 0x00	; 0
 74c:	86 e2       	ldi	r24, 0x26	; 38
 74e:	95 e0       	ldi	r25, 0x05	; 5
 750:	0e 94 50 03 	call	0x6a0	; 0x6a0 <SCH_Add_Task>
	SCH_Add_Task(SSD_BLINK , 0 , SSD_BLINK_PERIOD) ;
 754:	44 e6       	ldi	r20, 0x64	; 100
 756:	60 e0       	ldi	r22, 0x00	; 0
 758:	80 ec       	ldi	r24, 0xC0	; 192
 75a:	94 e0       	ldi	r25, 0x04	; 4
 75c:	0e 94 50 03 	call	0x6a0	; 0x6a0 <SCH_Add_Task>
		
	EEPROM_Write(INITIAL_TEMP , ADDRESS) ;
 760:	60 e0       	ldi	r22, 0x00	; 0
 762:	8c e3       	ldi	r24, 0x3C	; 60
 764:	0e 94 ac 04 	call	0x958	; 0x958 <EEPROM_Write>

	while(1)
    {
		SCH_Dispatch_Tasks() ;
 768:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SCH_Dispatch_Tasks>
 76c:	fd cf       	rjmp	.-6      	; 0x768 <main+0x60>

Disassembly of section .text.__vector_3:

000005ce <__vector_3>:
    }
}

ISR(INT2_vect)
{
 5ce:	1f 92       	push	r1
 5d0:	0f 92       	push	r0
 5d2:	0f b6       	in	r0, 0x3f	; 63
 5d4:	0f 92       	push	r0
 5d6:	11 24       	eor	r1, r1
 5d8:	2f 93       	push	r18
 5da:	3f 93       	push	r19
 5dc:	4f 93       	push	r20
 5de:	5f 93       	push	r21
 5e0:	6f 93       	push	r22
 5e2:	7f 93       	push	r23
 5e4:	8f 93       	push	r24
 5e6:	9f 93       	push	r25
 5e8:	af 93       	push	r26
 5ea:	bf 93       	push	r27
 5ec:	ef 93       	push	r30
 5ee:	ff 93       	push	r31
	switch( current_state )
 5f0:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <current_state>
 5f4:	88 23       	and	r24, r24
 5f6:	19 f0       	breq	.+6      	; 0x5fe <__vector_3+0x30>
 5f8:	81 30       	cpi	r24, 0x01	; 1
 5fa:	39 f0       	breq	.+14     	; 0x60a <__vector_3+0x3c>
 5fc:	0c c0       	rjmp	.+24     	; 0x616 <__vector_3+0x48>
	{
		case HEATER_OFF :
			current_state = HEATER_ON ;
 5fe:	81 e0       	ldi	r24, 0x01	; 1
 600:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <current_state>
			SCH_Start() ;
 604:	0e 94 a6 05 	call	0xb4c	; 0xb4c <SCH_Start>
			break;
 608:	06 c0       	rjmp	.+12     	; 0x616 <__vector_3+0x48>
		
		case HEATER_ON :
			current_state = HEATER_OFF ;
 60a:	10 92 9f 00 	sts	0x009F, r1	; 0x80009f <current_state>
			OFF_STATE() ;
 60e:	0e 94 45 05 	call	0xa8a	; 0xa8a <OFF_STATE>
			SCH_STOP() ;
 612:	0e 94 a8 05 	call	0xb50	; 0xb50 <SCH_STOP>
	}
 616:	ff 91       	pop	r31
 618:	ef 91       	pop	r30
 61a:	bf 91       	pop	r27
 61c:	af 91       	pop	r26
 61e:	9f 91       	pop	r25
 620:	8f 91       	pop	r24
 622:	7f 91       	pop	r23
 624:	6f 91       	pop	r22
 626:	5f 91       	pop	r21
 628:	4f 91       	pop	r20
 62a:	3f 91       	pop	r19
 62c:	2f 91       	pop	r18
 62e:	0f 90       	pop	r0
 630:	0f be       	out	0x3f, r0	; 63
 632:	0f 90       	pop	r0
 634:	1f 90       	pop	r1
 636:	18 95       	reti

Disassembly of section .text.SCH_Add_Task:

000006a0 <SCH_Add_Task>:
	TCCR_1B =13;
}

u16 SCH_Add_Task( void (*pFunction)() , const u8 DELAY , const u8 PERIOD) 
{
	u16 Index = 0 ;
 6a0:	20 e0       	ldi	r18, 0x00	; 0
 6a2:	30 e0       	ldi	r19, 0x00	; 0
	
	// First find a gap in the array (if there is one)
	while ( (SCH_tasks_G[Index].ptask != 0) && (Index < SCH_MAX_TASKS) )
 6a4:	02 c0       	rjmp	.+4      	; 0x6aa <SCH_Add_Task+0xa>
	{
		Index++ ;
 6a6:	2f 5f       	subi	r18, 0xFF	; 255
 6a8:	3f 4f       	sbci	r19, 0xFF	; 255
u16 SCH_Add_Task( void (*pFunction)() , const u8 DELAY , const u8 PERIOD) 
{
	u16 Index = 0 ;
	
	// First find a gap in the array (if there is one)
	while ( (SCH_tasks_G[Index].ptask != 0) && (Index < SCH_MAX_TASKS) )
 6aa:	f9 01       	movw	r30, r18
 6ac:	ee 0f       	add	r30, r30
 6ae:	ff 1f       	adc	r31, r31
 6b0:	e2 0f       	add	r30, r18
 6b2:	f3 1f       	adc	r31, r19
 6b4:	ee 0f       	add	r30, r30
 6b6:	ff 1f       	adc	r31, r31
 6b8:	ef 59       	subi	r30, 0x9F	; 159
 6ba:	ff 4f       	sbci	r31, 0xFF	; 255
 6bc:	01 90       	ld	r0, Z+
 6be:	f0 81       	ld	r31, Z
 6c0:	e0 2d       	mov	r30, r0
 6c2:	ef 2b       	or	r30, r31
 6c4:	19 f0       	breq	.+6      	; 0x6cc <SCH_Add_Task+0x2c>
 6c6:	28 30       	cpi	r18, 0x08	; 8
 6c8:	31 05       	cpc	r19, r1
 6ca:	68 f3       	brcs	.-38     	; 0x6a6 <SCH_Add_Task+0x6>
	{
		Index++ ;
	}
	
	// Have we reached the end of the list? 
	if ( Index == SCH_MAX_TASKS )
 6cc:	28 30       	cpi	r18, 0x08	; 8
 6ce:	31 05       	cpc	r19, r1
 6d0:	49 f4       	brne	.+18     	; 0x6e4 <SCH_Add_Task+0x44>
	{
		// Task list is full
		//
		// Set the global error variable
		Error_Code_G = ERROR_SCH_TOO_MANY_TASKS ;
 6d2:	81 e0       	ldi	r24, 0x01	; 1
 6d4:	90 e0       	ldi	r25, 0x00	; 0
 6d6:	90 93 9c 00 	sts	0x009C, r25	; 0x80009c <Error_Code_G+0x1>
 6da:	80 93 9b 00 	sts	0x009B, r24	; 0x80009b <Error_Code_G>
		
		// Also return an error code
		return SCH_MAX_TASKS ;
 6de:	88 e0       	ldi	r24, 0x08	; 8
 6e0:	90 e0       	ldi	r25, 0x00	; 0
 6e2:	08 95       	ret
	}
	
	// If we're here, there is a space in the task array
	SCH_tasks_G[Index].ptask = pFunction ;
 6e4:	f9 01       	movw	r30, r18
 6e6:	ee 0f       	add	r30, r30
 6e8:	ff 1f       	adc	r31, r31
 6ea:	e2 0f       	add	r30, r18
 6ec:	f3 1f       	adc	r31, r19
 6ee:	ee 0f       	add	r30, r30
 6f0:	ff 1f       	adc	r31, r31
 6f2:	ef 59       	subi	r30, 0x9F	; 159
 6f4:	ff 4f       	sbci	r31, 0xFF	; 255
 6f6:	91 83       	std	Z+1, r25	; 0x01
 6f8:	80 83       	st	Z, r24
	SCH_tasks_G[Index].delay = DELAY ;
 6fa:	62 83       	std	Z+2, r22	; 0x02
	SCH_tasks_G[Index].priod = PERIOD ;
 6fc:	43 83       	std	Z+3, r20	; 0x03
	SCH_tasks_G[Index].RunMe = 0 ;
 6fe:	15 82       	std	Z+5, r1	; 0x05
 700:	14 82       	std	Z+4, r1	; 0x04
	
	// return position of task (to allow later deletion)
	return Index ;	
 702:	82 2f       	mov	r24, r18
 704:	93 2f       	mov	r25, r19
}
 706:	08 95       	ret

Disassembly of section .text.SCH_Start:

00000b4c <SCH_Start>:
	SCH_Go_To_Sleep() ;
}

void SCH_Start(void)
{
	sei() ;
 b4c:	78 94       	sei
 b4e:	08 95       	ret

Disassembly of section .text.SCH_STOP:

00000b50 <SCH_STOP>:
}

void SCH_STOP(void)
{
	cli() ;
 b50:	f8 94       	cli
 b52:	08 95       	ret

Disassembly of section .text.SCH_Delete_Task:

0000076e <SCH_Delete_Task>:
}

u16 SCH_Delete_Task(const u16 Task_Index)
{
 76e:	9c 01       	movw	r18, r24
	u16 Return_Code ;
	
	if ( SCH_tasks_G[Task_Index].ptask == 0 )
 770:	fc 01       	movw	r30, r24
 772:	ee 0f       	add	r30, r30
 774:	ff 1f       	adc	r31, r31
 776:	e8 0f       	add	r30, r24
 778:	f9 1f       	adc	r31, r25
 77a:	ee 0f       	add	r30, r30
 77c:	ff 1f       	adc	r31, r31
 77e:	ef 59       	subi	r30, 0x9F	; 159
 780:	ff 4f       	sbci	r31, 0xFF	; 255
 782:	80 81       	ld	r24, Z
 784:	91 81       	ldd	r25, Z+1	; 0x01
 786:	89 2b       	or	r24, r25
 788:	49 f4       	brne	.+18     	; 0x79c <SCH_Delete_Task+0x2e>
	{
		//No task at this location...
		//
		//set the global error variable
		Error_Code_G = ERROR_SCH_CANNOT_DELETE_TASK ;
 78a:	82 e0       	ldi	r24, 0x02	; 2
 78c:	90 e0       	ldi	r25, 0x00	; 0
 78e:	90 93 9c 00 	sts	0x009C, r25	; 0x80009c <Error_Code_G+0x1>
 792:	80 93 9b 00 	sts	0x009B, r24	; 0x80009b <Error_Code_G>
		//...also return an error code
		Return_Code = RETURN_ERROR ;
 796:	81 e0       	ldi	r24, 0x01	; 1
 798:	90 e0       	ldi	r25, 0x00	; 0
 79a:	02 c0       	rjmp	.+4      	; 0x7a0 <SCH_Delete_Task+0x32>
	}
	else
	{
		Return_Code = RETURN_NORMAL ;
 79c:	80 e0       	ldi	r24, 0x00	; 0
 79e:	90 e0       	ldi	r25, 0x00	; 0
	}
	
	SCH_tasks_G[Task_Index].ptask = 0x0000 ;
 7a0:	f9 01       	movw	r30, r18
 7a2:	ee 0f       	add	r30, r30
 7a4:	ff 1f       	adc	r31, r31
 7a6:	df 01       	movw	r26, r30
 7a8:	a2 0f       	add	r26, r18
 7aa:	b3 1f       	adc	r27, r19
 7ac:	aa 0f       	add	r26, r26
 7ae:	bb 1f       	adc	r27, r27
 7b0:	af 59       	subi	r26, 0x9F	; 159
 7b2:	bf 4f       	sbci	r27, 0xFF	; 255
 7b4:	11 96       	adiw	r26, 0x01	; 1
 7b6:	1c 92       	st	X, r1
 7b8:	1e 92       	st	-X, r1
	SCH_tasks_G[Task_Index].delay = 0 ;
 7ba:	12 96       	adiw	r26, 0x02	; 2
 7bc:	1c 92       	st	X, r1
 7be:	12 97       	sbiw	r26, 0x02	; 2
	SCH_tasks_G[Task_Index].priod = 0 ;
 7c0:	13 96       	adiw	r26, 0x03	; 3
 7c2:	1c 92       	st	X, r1
 7c4:	13 97       	sbiw	r26, 0x03	; 3
	
	SCH_tasks_G[Task_Index].RunMe = 0 ;
 7c6:	fd 01       	movw	r30, r26
 7c8:	15 82       	std	Z+5, r1	; 0x05
 7ca:	14 82       	std	Z+4, r1	; 0x04
	
	return Return_Code ;		//return status
}
 7cc:	08 95       	ret

Disassembly of section .text.SCH_Init_T1:

000008ce <SCH_Init_T1>:
//Used to display the error code
u16 Error_Code_G = 0 ;


void SCH_Init_T1 (void) 
{
 8ce:	cf 93       	push	r28
 8d0:	df 93       	push	r29
	u16 i ;
	
	for ( i=0 ; i< SCH_MAX_TASKS ; i++ )
 8d2:	c0 e0       	ldi	r28, 0x00	; 0
 8d4:	d0 e0       	ldi	r29, 0x00	; 0
 8d6:	04 c0       	rjmp	.+8      	; 0x8e0 <SCH_Init_T1+0x12>
	{
		SCH_Delete_Task(i) ;
 8d8:	ce 01       	movw	r24, r28
 8da:	0e 94 b7 03 	call	0x76e	; 0x76e <SCH_Delete_Task>

void SCH_Init_T1 (void) 
{
	u16 i ;
	
	for ( i=0 ; i< SCH_MAX_TASKS ; i++ )
 8de:	21 96       	adiw	r28, 0x01	; 1
 8e0:	c8 30       	cpi	r28, 0x08	; 8
 8e2:	d1 05       	cpc	r29, r1
 8e4:	c8 f3       	brcs	.-14     	; 0x8d8 <SCH_Init_T1+0xa>
	}
	
	// Reset the global error variable
	// - SCH_Delete_Task() will generate an error code,
	// (because the task array is empty)
	Error_Code_G = 0 ;
 8e6:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <Error_Code_G+0x1>
 8ea:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <Error_Code_G>
	
	TIMSK_  |=0x10; //Enable interrupt for timer over flow.
 8ee:	89 b7       	in	r24, 0x39	; 57
 8f0:	80 61       	ori	r24, 0x10	; 16
 8f2:	89 bf       	out	0x39, r24	; 57
	SREG   |=0x80; //Enable the global interrupt.
 8f4:	8f b7       	in	r24, 0x3f	; 63
 8f6:	80 68       	ori	r24, 0x80	; 128
 8f8:	8f bf       	out	0x3f, r24	; 63
	//Timer1_Manual_Reload();
	TCCR_1A |=0x00; //OC1A state at compare match & mode of the timer.
 8fa:	8f b5       	in	r24, 0x2f	; 47
 8fc:	8f bd       	out	0x2f, r24	; 47
	TCNT_1 =0;
 8fe:	1d bc       	out	0x2d, r1	; 45
 900:	1c bc       	out	0x2c, r1	; 44
	OCR_1A=16;
 902:	80 e1       	ldi	r24, 0x10	; 16
 904:	90 e0       	ldi	r25, 0x00	; 0
 906:	9b bd       	out	0x2b, r25	; 43
 908:	8a bd       	out	0x2a, r24	; 42
	TCCR_1B =13;
 90a:	8d e0       	ldi	r24, 0x0D	; 13
 90c:	8e bd       	out	0x2e, r24	; 46
}
 90e:	df 91       	pop	r29
 910:	cf 91       	pop	r28
 912:	08 95       	ret

Disassembly of section .text.SCH_Go_To_Sleep:

00000aa0 <SCH_Go_To_Sleep>:
}

void SCH_Go_To_Sleep(void)
{
	// Enter idle mode 
	CLEAR_BIT(MCUCR , SM2) ;
 aa0:	85 b7       	in	r24, 0x35	; 53
 aa2:	8f 7b       	andi	r24, 0xBF	; 191
 aa4:	85 bf       	out	0x35, r24	; 53
	CLEAR_BIT(MCUCR , SM1) ;
 aa6:	85 b7       	in	r24, 0x35	; 53
 aa8:	8f 7d       	andi	r24, 0xDF	; 223
 aaa:	85 bf       	out	0x35, r24	; 53
	CLEAR_BIT(MCUCR , SM0) ;
 aac:	85 b7       	in	r24, 0x35	; 53
 aae:	8f 7e       	andi	r24, 0xEF	; 239
 ab0:	85 bf       	out	0x35, r24	; 53
 ab2:	08 95       	ret

Disassembly of section .text.SCH_Dispatch_Tasks:

000007ce <SCH_Dispatch_Tasks>:
	// return position of task (to allow later deletion)
	return Index ;	
}

void SCH_Dispatch_Tasks( void )
{
 7ce:	0f 93       	push	r16
 7d0:	1f 93       	push	r17
 7d2:	cf 93       	push	r28
 7d4:	df 93       	push	r29
	u16 Index ;
	
	//Dispatches (runs) the next task (if one is readt)
	for ( Index=0 ; Index<SCH_MAX_TASKS ; Index++ )
 7d6:	c0 e0       	ldi	r28, 0x00	; 0
 7d8:	d0 e0       	ldi	r29, 0x00	; 0
 7da:	1f c0       	rjmp	.+62     	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
	{
		if ( SCH_tasks_G[Index].RunMe > 0 )
 7dc:	fe 01       	movw	r30, r28
 7de:	ee 0f       	add	r30, r30
 7e0:	ff 1f       	adc	r31, r31
 7e2:	ec 0f       	add	r30, r28
 7e4:	fd 1f       	adc	r31, r29
 7e6:	ee 0f       	add	r30, r30
 7e8:	ff 1f       	adc	r31, r31
 7ea:	ef 59       	subi	r30, 0x9F	; 159
 7ec:	ff 4f       	sbci	r31, 0xFF	; 255
 7ee:	84 81       	ldd	r24, Z+4	; 0x04
 7f0:	95 81       	ldd	r25, Z+5	; 0x05
 7f2:	89 2b       	or	r24, r25
 7f4:	89 f0       	breq	.+34     	; 0x818 <__DATA_REGION_LENGTH__+0x18>
		{
			(*SCH_tasks_G[Index].ptask)() ;		// Run the task
 7f6:	8f 01       	movw	r16, r30
 7f8:	01 90       	ld	r0, Z+
 7fa:	f0 81       	ld	r31, Z
 7fc:	e0 2d       	mov	r30, r0
 7fe:	09 95       	icall
			
			SCH_tasks_G[Index].RunMe -= 1 ;		// Reset / reduce RunMe flag
 800:	f8 01       	movw	r30, r16
 802:	84 81       	ldd	r24, Z+4	; 0x04
 804:	95 81       	ldd	r25, Z+5	; 0x05
 806:	01 97       	sbiw	r24, 0x01	; 1
 808:	95 83       	std	Z+5, r25	; 0x05
 80a:	84 83       	std	Z+4, r24	; 0x04
			
			//Periodic tasks will automatically run again
			//- if this is a 'one shot' task, remove it from the array 
			if ( SCH_tasks_G[Index].priod == 0 )
 80c:	83 81       	ldd	r24, Z+3	; 0x03
 80e:	81 11       	cpse	r24, r1
 810:	03 c0       	rjmp	.+6      	; 0x818 <__DATA_REGION_LENGTH__+0x18>
			{
				SCH_Delete_Task(Index) ;
 812:	ce 01       	movw	r24, r28
 814:	0e 94 b7 03 	call	0x76e	; 0x76e <SCH_Delete_Task>
void SCH_Dispatch_Tasks( void )
{
	u16 Index ;
	
	//Dispatches (runs) the next task (if one is readt)
	for ( Index=0 ; Index<SCH_MAX_TASKS ; Index++ )
 818:	21 96       	adiw	r28, 0x01	; 1
 81a:	c8 30       	cpi	r28, 0x08	; 8
 81c:	d1 05       	cpc	r29, r1
 81e:	f0 f2       	brcs	.-68     	; 0x7dc <SCH_Dispatch_Tasks+0xe>
	
	//Report system status
	SCH_Report_Status() ;
	
	//The scheduler enters idle mode at this point
	SCH_Go_To_Sleep() ;
 820:	0e 94 50 05 	call	0xaa0	; 0xaa0 <SCH_Go_To_Sleep>
}
 824:	df 91       	pop	r29
 826:	cf 91       	pop	r28
 828:	1f 91       	pop	r17
 82a:	0f 91       	pop	r16
 82c:	08 95       	ret

Disassembly of section .text.SCH_Update:

00000438 <SCH_Update>:
{
	u16 Index ;
	
	//INTF2 = 0 ;		// Have to manually clear this. 
	
	for ( Index=0 ; Index<SCH_MAX_TASKS ; Index++ )
 438:	80 e0       	ldi	r24, 0x00	; 0
 43a:	90 e0       	ldi	r25, 0x00	; 0
 43c:	42 c0       	rjmp	.+132    	; 0x4c2 <SCH_Update+0x8a>
	{
		//Check if there is a task at this location
		if ( SCH_tasks_G[Index].ptask )
 43e:	fc 01       	movw	r30, r24
 440:	ee 0f       	add	r30, r30
 442:	ff 1f       	adc	r31, r31
 444:	e8 0f       	add	r30, r24
 446:	f9 1f       	adc	r31, r25
 448:	ee 0f       	add	r30, r30
 44a:	ff 1f       	adc	r31, r31
 44c:	ef 59       	subi	r30, 0x9F	; 159
 44e:	ff 4f       	sbci	r31, 0xFF	; 255
 450:	20 81       	ld	r18, Z
 452:	31 81       	ldd	r19, Z+1	; 0x01
 454:	23 2b       	or	r18, r19
 456:	a1 f1       	breq	.+104    	; 0x4c0 <SCH_Update+0x88>
		{
			if ( SCH_tasks_G[Index].delay == 0 )
 458:	fc 01       	movw	r30, r24
 45a:	ee 0f       	add	r30, r30
 45c:	ff 1f       	adc	r31, r31
 45e:	e8 0f       	add	r30, r24
 460:	f9 1f       	adc	r31, r25
 462:	ee 0f       	add	r30, r30
 464:	ff 1f       	adc	r31, r31
 466:	ef 59       	subi	r30, 0x9F	; 159
 468:	ff 4f       	sbci	r31, 0xFF	; 255
 46a:	22 81       	ldd	r18, Z+2	; 0x02
 46c:	21 11       	cpse	r18, r1
 46e:	1d c0       	rjmp	.+58     	; 0x4aa <SCH_Update+0x72>
			{
				//The task is due to run
				SCH_tasks_G[Index].RunMe += 1 ;		//Inc. the 'RunMe' flag
 470:	fc 01       	movw	r30, r24
 472:	ee 0f       	add	r30, r30
 474:	ff 1f       	adc	r31, r31
 476:	e8 0f       	add	r30, r24
 478:	f9 1f       	adc	r31, r25
 47a:	ee 0f       	add	r30, r30
 47c:	ff 1f       	adc	r31, r31
 47e:	ef 59       	subi	r30, 0x9F	; 159
 480:	ff 4f       	sbci	r31, 0xFF	; 255
 482:	24 81       	ldd	r18, Z+4	; 0x04
 484:	35 81       	ldd	r19, Z+5	; 0x05
 486:	2f 5f       	subi	r18, 0xFF	; 255
 488:	3f 4f       	sbci	r19, 0xFF	; 255
 48a:	35 83       	std	Z+5, r19	; 0x05
 48c:	24 83       	std	Z+4, r18	; 0x04
			
				if ( SCH_tasks_G[Index].priod )
 48e:	23 81       	ldd	r18, Z+3	; 0x03
 490:	22 23       	and	r18, r18
 492:	b1 f0       	breq	.+44     	; 0x4c0 <SCH_Update+0x88>
				{
					//Schedule periodic tasks to run again
					SCH_tasks_G[Index].delay = SCH_tasks_G[Index].priod ;
 494:	fc 01       	movw	r30, r24
 496:	ee 0f       	add	r30, r30
 498:	ff 1f       	adc	r31, r31
 49a:	e8 0f       	add	r30, r24
 49c:	f9 1f       	adc	r31, r25
 49e:	ee 0f       	add	r30, r30
 4a0:	ff 1f       	adc	r31, r31
 4a2:	ef 59       	subi	r30, 0x9F	; 159
 4a4:	ff 4f       	sbci	r31, 0xFF	; 255
 4a6:	22 83       	std	Z+2, r18	; 0x02
 4a8:	0b c0       	rjmp	.+22     	; 0x4c0 <SCH_Update+0x88>
				}
			}
			else
			{
				//Not yet ready to run : just decrement the delay
				SCH_tasks_G[Index].delay -= 1 ;
 4aa:	fc 01       	movw	r30, r24
 4ac:	ee 0f       	add	r30, r30
 4ae:	ff 1f       	adc	r31, r31
 4b0:	e8 0f       	add	r30, r24
 4b2:	f9 1f       	adc	r31, r25
 4b4:	ee 0f       	add	r30, r30
 4b6:	ff 1f       	adc	r31, r31
 4b8:	ef 59       	subi	r30, 0x9F	; 159
 4ba:	ff 4f       	sbci	r31, 0xFF	; 255
 4bc:	21 50       	subi	r18, 0x01	; 1
 4be:	22 83       	std	Z+2, r18	; 0x02
{
	u16 Index ;
	
	//INTF2 = 0 ;		// Have to manually clear this. 
	
	for ( Index=0 ; Index<SCH_MAX_TASKS ; Index++ )
 4c0:	01 96       	adiw	r24, 0x01	; 1
 4c2:	88 30       	cpi	r24, 0x08	; 8
 4c4:	91 05       	cpc	r25, r1
 4c6:	08 f4       	brcc	.+2      	; 0x4ca <SCH_Update+0x92>
 4c8:	ba cf       	rjmp	.-140    	; 0x43e <SCH_Update+0x6>
				//Not yet ready to run : just decrement the delay
				SCH_tasks_G[Index].delay -= 1 ;
			}
		}
	}
 4ca:	08 95       	ret

Disassembly of section .text.__vector_7:

00000886 <__vector_7>:
#endif
}

//This is the scheduler ISR.
ISR ( TIMER1_COMPA_vect )
{
 886:	1f 92       	push	r1
 888:	0f 92       	push	r0
 88a:	0f b6       	in	r0, 0x3f	; 63
 88c:	0f 92       	push	r0
 88e:	11 24       	eor	r1, r1
 890:	2f 93       	push	r18
 892:	3f 93       	push	r19
 894:	4f 93       	push	r20
 896:	5f 93       	push	r21
 898:	6f 93       	push	r22
 89a:	7f 93       	push	r23
 89c:	8f 93       	push	r24
 89e:	9f 93       	push	r25
 8a0:	af 93       	push	r26
 8a2:	bf 93       	push	r27
 8a4:	ef 93       	push	r30
 8a6:	ff 93       	push	r31
	SCH_Update() ;
 8a8:	0e 94 1c 02 	call	0x438	; 0x438 <SCH_Update>
}
 8ac:	ff 91       	pop	r31
 8ae:	ef 91       	pop	r30
 8b0:	bf 91       	pop	r27
 8b2:	af 91       	pop	r26
 8b4:	9f 91       	pop	r25
 8b6:	8f 91       	pop	r24
 8b8:	7f 91       	pop	r23
 8ba:	6f 91       	pop	r22
 8bc:	5f 91       	pop	r21
 8be:	4f 91       	pop	r20
 8c0:	3f 91       	pop	r19
 8c2:	2f 91       	pop	r18
 8c4:	0f 90       	pop	r0
 8c6:	0f be       	out	0x3f, r0	; 63
 8c8:	0f 90       	pop	r0
 8ca:	1f 90       	pop	r1
 8cc:	18 95       	reti

Disassembly of section .text.SSD_TURN_OFF:

00000a6c <SSD_TURN_OFF>:
	SSD_TURN_OFF() ;
}

void SSD_TURN_OFF(void)
{
	GPIO_voidSetPortValue(SSD_PORT , 0x00) ;
 a6c:	60 e0       	ldi	r22, 0x00	; 0
 a6e:	83 e0       	ldi	r24, 0x03	; 3
 a70:	0e 94 06 05 	call	0xa0c	; 0xa0c <GPIO_voidSetPortValue>
	GPIO_voidSetPortPinValue(SSD_EN_PORT , SSD1_EN_PIN , 0) ;
 a74:	40 e0       	ldi	r20, 0x00	; 0
 a76:	63 e0       	ldi	r22, 0x03	; 3
 a78:	82 e0       	ldi	r24, 0x02	; 2
 a7a:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
	GPIO_voidSetPortPinValue(SSD_EN_PORT , SSD2_EN_PIN , 0) ;
 a7e:	40 e0       	ldi	r20, 0x00	; 0
 a80:	64 e0       	ldi	r22, 0x04	; 4
 a82:	82 e0       	ldi	r24, 0x02	; 2
 a84:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
 a88:	08 95       	ret

Disassembly of section .text.SSD_Init:

000009ca <SSD_Init>:

u8 ssd[] = { 0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90 } ;
	
void SSD_Init(void)
{
	GPIO_voidSetPortDirection(SSD_PORT , OUTPUT) ;	
 9ca:	61 e0       	ldi	r22, 0x01	; 1
 9cc:	83 e0       	ldi	r24, 0x03	; 3
 9ce:	0e 94 17 04 	call	0x82e	; 0x82e <GPIO_voidSetPortDirection>
	GPIO_voidSetPortPinDirection(SSD_EN_PORT , SSD1_EN_PIN , OUTPUT) ;	
 9d2:	41 e0       	ldi	r20, 0x01	; 1
 9d4:	63 e0       	ldi	r22, 0x03	; 3
 9d6:	82 e0       	ldi	r24, 0x02	; 2
 9d8:	0e 94 63 00 	call	0xc6	; 0xc6 <__data_load_end>
	GPIO_voidSetPortPinDirection(SSD_EN_PORT , SSD1_EN_PIN , OUTPUT) ;
 9dc:	41 e0       	ldi	r20, 0x01	; 1
 9de:	63 e0       	ldi	r22, 0x03	; 3
 9e0:	82 e0       	ldi	r24, 0x02	; 2
 9e2:	0e 94 63 00 	call	0xc6	; 0xc6 <__data_load_end>
	
	SSD_TURN_OFF() ;
 9e6:	0e 94 36 05 	call	0xa6c	; 0xa6c <SSD_TURN_OFF>
 9ea:	08 95       	ret

Disassembly of section .text.SSD_BLINK:

00000980 <SSD_BLINK>:
	GPIO_voidSetPortPinValue(SSD_EN_PORT , SSD2_EN_PIN , 1) ;
}

void SSD_BLINK(void)
{
	if( current_mode == SETTING_MODE )
 980:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <current_mode>
 984:	81 11       	cpse	r24, r1
 986:	0e c0       	rjmp	.+28     	; 0x9a4 <SSD_BLINK+0x24>
	{
		if (SSD_MODE == SSD_ON)
 988:	80 91 a2 00 	lds	r24, 0x00A2	; 0x8000a2 <SSD_MODE>
 98c:	81 11       	cpse	r24, r1
 98e:	06 c0       	rjmp	.+12     	; 0x99c <SSD_BLINK+0x1c>
		{
			SSD_MODE = SSD_OFF ;
 990:	81 e0       	ldi	r24, 0x01	; 1
 992:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <SSD_MODE>
			SSD_TURN_OFF() ;
 996:	0e 94 36 05 	call	0xa6c	; 0xa6c <SSD_TURN_OFF>
 99a:	08 95       	ret
		}
		else if (SSD_MODE == SSD_OFF)
 99c:	81 30       	cpi	r24, 0x01	; 1
 99e:	11 f4       	brne	.+4      	; 0x9a4 <SSD_BLINK+0x24>
		{
			SSD_MODE = SSD_ON ;
 9a0:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <SSD_MODE>
 9a4:	08 95       	ret

Disassembly of section .text.segment7_display:

000004cc <segment7_display>:
}

void SSD_TURN_ON(void)
{
	GPIO_voidSetPortPinValue(SSD_EN_PORT , SSD1_EN_PIN , 1) ;
	GPIO_voidSetPortPinValue(SSD_EN_PORT , SSD2_EN_PIN , 1) ;
 4cc:	cf 93       	push	r28
 4ce:	90 91 a1 00 	lds	r25, 0x00A1	; 0x8000a1 <SSD_Disp>
 4d2:	99 23       	and	r25, r25
 4d4:	19 f0       	breq	.+6      	; 0x4dc <segment7_display+0x10>
 4d6:	91 30       	cpi	r25, 0x01	; 1
 4d8:	f1 f0       	breq	.+60     	; 0x516 <segment7_display+0x4a>
 4da:	3f c0       	rjmp	.+126    	; 0x55a <segment7_display+0x8e>
 4dc:	ed ec       	ldi	r30, 0xCD	; 205
 4de:	8e 9f       	mul	r24, r30
 4e0:	e1 2d       	mov	r30, r1
 4e2:	11 24       	eor	r1, r1
 4e4:	e6 95       	lsr	r30
 4e6:	e6 95       	lsr	r30
 4e8:	e6 95       	lsr	r30
 4ea:	f0 e0       	ldi	r31, 0x00	; 0
 4ec:	ef 56       	subi	r30, 0x6F	; 111
 4ee:	ff 4f       	sbci	r31, 0xFF	; 255
 4f0:	c0 81       	ld	r28, Z
 4f2:	41 e0       	ldi	r20, 0x01	; 1
 4f4:	63 e0       	ldi	r22, 0x03	; 3
 4f6:	82 e0       	ldi	r24, 0x02	; 2
 4f8:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
 4fc:	40 e0       	ldi	r20, 0x00	; 0
 4fe:	64 e0       	ldi	r22, 0x04	; 4
 500:	82 e0       	ldi	r24, 0x02	; 2
 502:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
 506:	6c 2f       	mov	r22, r28
 508:	83 e0       	ldi	r24, 0x03	; 3
 50a:	0e 94 06 05 	call	0xa0c	; 0xa0c <GPIO_voidSetPortValue>
 50e:	81 e0       	ldi	r24, 0x01	; 1
 510:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <SSD_Disp>
 514:	22 c0       	rjmp	.+68     	; 0x55a <segment7_display+0x8e>
 516:	9d ec       	ldi	r25, 0xCD	; 205
 518:	89 9f       	mul	r24, r25
 51a:	91 2d       	mov	r25, r1
 51c:	11 24       	eor	r1, r1
 51e:	96 95       	lsr	r25
 520:	96 95       	lsr	r25
 522:	96 95       	lsr	r25
 524:	99 0f       	add	r25, r25
 526:	29 2f       	mov	r18, r25
 528:	22 0f       	add	r18, r18
 52a:	22 0f       	add	r18, r18
 52c:	92 0f       	add	r25, r18
 52e:	89 1b       	sub	r24, r25
 530:	e8 2f       	mov	r30, r24
 532:	f0 e0       	ldi	r31, 0x00	; 0
 534:	ef 56       	subi	r30, 0x6F	; 111
 536:	ff 4f       	sbci	r31, 0xFF	; 255
 538:	c0 81       	ld	r28, Z
 53a:	41 e0       	ldi	r20, 0x01	; 1
 53c:	64 e0       	ldi	r22, 0x04	; 4
 53e:	82 e0       	ldi	r24, 0x02	; 2
 540:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
 544:	40 e0       	ldi	r20, 0x00	; 0
 546:	63 e0       	ldi	r22, 0x03	; 3
 548:	82 e0       	ldi	r24, 0x02	; 2
 54a:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
 54e:	6c 2f       	mov	r22, r28
 550:	83 e0       	ldi	r24, 0x03	; 3
 552:	0e 94 06 05 	call	0xa0c	; 0xa0c <GPIO_voidSetPortValue>
 556:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <SSD_Disp>
 55a:	cf 91       	pop	r28
 55c:	08 95       	ret

Disassembly of section .text.SSD_UPDATE:

00000a4c <SSD_UPDATE>:
	
}

void SSD_UPDATE(void)
{
	u8 tem = Get_Current_Temp() ;
 a4c:	0e 94 a1 05 	call	0xb42	; 0xb42 <Get_Current_Temp>
	
	switch(current_mode)
 a50:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <current_mode>
 a54:	99 23       	and	r25, r25
 a56:	39 f0       	breq	.+14     	; 0xa66 <SSD_UPDATE+0x1a>
 a58:	91 30       	cpi	r25, 0x01	; 1
 a5a:	39 f4       	brne	.+14     	; 0xa6a <SSD_UPDATE+0x1e>
	{
		case NORMAL_MODE :
			segment7_display( sensed_temp ) ;
 a5c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 a60:	0e 94 66 02 	call	0x4cc	; 0x4cc <segment7_display>
			break;
 a64:	08 95       	ret
		
		case SETTING_MODE :
			segment7_display( tem ) ;
 a66:	0e 94 66 02 	call	0x4cc	; 0x4cc <segment7_display>
 a6a:	08 95       	ret

Disassembly of section .text.SW_Init:

00000914 <SW_Init>:

extern u8 sensed_temp ;

void SW_Init(void)
{		
	GPIO_voidSetPortPinDirection(UP_PORT , UP_PIN , UP_DIR) ;
 914:	40 e0       	ldi	r20, 0x00	; 0
 916:	63 e0       	ldi	r22, 0x03	; 3
 918:	81 e0       	ldi	r24, 0x01	; 1
 91a:	0e 94 63 00 	call	0xc6	; 0xc6 <__data_load_end>
	GPIO_voidSetPortPinDirection(DOWN_PORT , DOWN_PIN , DOWN_DIR) ;
 91e:	40 e0       	ldi	r20, 0x00	; 0
 920:	64 e0       	ldi	r22, 0x04	; 4
 922:	81 e0       	ldi	r24, 0x01	; 1
 924:	0e 94 63 00 	call	0xc6	; 0xc6 <__data_load_end>
	GPIO_voidSetPortPinDirection(ON_OFF_PORT , ON_OFF_PIN , ON_OFF_PIN) ;
 928:	42 e0       	ldi	r20, 0x02	; 2
 92a:	62 e0       	ldi	r22, 0x02	; 2
 92c:	81 e0       	ldi	r24, 0x01	; 1
 92e:	0e 94 63 00 	call	0xc6	; 0xc6 <__data_load_end>
	
	GPIO_voidSetPortPinValue(UP_PORT , UP_PIN , 1) ;
 932:	41 e0       	ldi	r20, 0x01	; 1
 934:	63 e0       	ldi	r22, 0x03	; 3
 936:	81 e0       	ldi	r24, 0x01	; 1
 938:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>
	GPIO_voidSetPortPinValue(DOWN_PORT , DOWN_PIN , 1) ;
 93c:	41 e0       	ldi	r20, 0x01	; 1
 93e:	64 e0       	ldi	r22, 0x04	; 4
 940:	81 e0       	ldi	r24, 0x01	; 1
 942:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <GPIO_voidSetPortPinValue>

	current_mode = NORMAL_MODE ;
 946:	81 e0       	ldi	r24, 0x01	; 1
 948:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <current_mode>
	set_temp = INITIAL_TEMP ;
 94c:	8c e3       	ldi	r24, 0x3C	; 60
 94e:	80 93 a3 00 	sts	0x00A3, r24	; 0x8000a3 <set_temp>
	
	Save_Last_Temp() ;
 952:	0e 94 90 05 	call	0xb20	; 0xb20 <Save_Last_Temp>
 956:	08 95       	ret

Disassembly of section .text.Heat_Cool_Elements:

0000055e <Heat_Cool_Elements>:
}

void Heat_Cool_Elements(void)
{
	if ( current_mode == NORMAL_MODE )
 55e:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <current_mode>
 562:	81 30       	cpi	r24, 0x01	; 1
 564:	59 f5       	brne	.+86     	; 0x5bc <Heat_Cool_Elements+0x5e>
	{
		if ( sensed_temp < (set_temp - TEMP_CHANGE) )
 566:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 56a:	30 e0       	ldi	r19, 0x00	; 0
 56c:	80 91 a3 00 	lds	r24, 0x00A3	; 0x8000a3 <set_temp>
 570:	90 e0       	ldi	r25, 0x00	; 0
 572:	ac 01       	movw	r20, r24
 574:	45 50       	subi	r20, 0x05	; 5
 576:	51 09       	sbc	r21, r1
 578:	24 17       	cp	r18, r20
 57a:	35 07       	cpc	r19, r21
 57c:	4c f4       	brge	.+18     	; 0x590 <Heat_Cool_Elements+0x32>
		{
			heating_set_state(heat_ON) ;
 57e:	81 e0       	ldi	r24, 0x01	; 1
 580:	0e 94 16 05 	call	0xa2c	; 0xa2c <heating_set_state>
			cooling_set_state(cool_OFF) ;
 584:	80 e0       	ldi	r24, 0x00	; 0
 586:	0e 94 f6 04 	call	0x9ec	; 0x9ec <cooling_set_state>
			LED_Blink() ;
 58a:	0e 94 96 05 	call	0xb2c	; 0xb2c <LED_Blink>
 58e:	08 95       	ret
		}
		else if ( sensed_temp > (set_temp + TEMP_CHANGE) )
 590:	05 96       	adiw	r24, 0x05	; 5
 592:	82 17       	cp	r24, r18
 594:	93 07       	cpc	r25, r19
 596:	4c f4       	brge	.+18     	; 0x5aa <Heat_Cool_Elements+0x4c>
		{
			heating_set_state(heat_OFF) ;
 598:	80 e0       	ldi	r24, 0x00	; 0
 59a:	0e 94 16 05 	call	0xa2c	; 0xa2c <heating_set_state>
			cooling_set_state(cool_ON) ;
 59e:	81 e0       	ldi	r24, 0x01	; 1
 5a0:	0e 94 f6 04 	call	0x9ec	; 0x9ec <cooling_set_state>
			LED_ON() ;
 5a4:	0e 94 84 05 	call	0xb08	; 0xb08 <LED_ON>
 5a8:	08 95       	ret
		}
		else
		{
			heating_set_state(heat_OFF) ;
 5aa:	80 e0       	ldi	r24, 0x00	; 0
 5ac:	0e 94 16 05 	call	0xa2c	; 0xa2c <heating_set_state>
			cooling_set_state(cool_OFF) ;
 5b0:	80 e0       	ldi	r24, 0x00	; 0
 5b2:	0e 94 f6 04 	call	0x9ec	; 0x9ec <cooling_set_state>
			LED_OFF() ;
 5b6:	0e 94 8a 05 	call	0xb14	; 0xb14 <LED_OFF>
 5ba:	08 95       	ret
		}
	}
	else
	{
		heating_set_state(heat_OFF) ;
 5bc:	80 e0       	ldi	r24, 0x00	; 0
 5be:	0e 94 16 05 	call	0xa2c	; 0xa2c <heating_set_state>
		cooling_set_state(cool_OFF) ;
 5c2:	80 e0       	ldi	r24, 0x00	; 0
 5c4:	0e 94 f6 04 	call	0x9ec	; 0x9ec <cooling_set_state>
		LED_OFF() ;
 5c8:	0e 94 8a 05 	call	0xb14	; 0xb14 <LED_OFF>
 5cc:	08 95       	ret

Disassembly of section .text.Get_Current_Temp:

00000b42 <Get_Current_Temp>:
}

u8 Get_Current_Temp(void)
{
	return set_temp ;
}
 b42:	80 91 a3 00 	lds	r24, 0x00A3	; 0x8000a3 <set_temp>
 b46:	08 95       	ret

Disassembly of section .text.SW_ST:

0000036c <SW_ST>:

void SW_ST(void)
{
	switch ( current_mode )
 36c:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <current_mode>
 370:	88 23       	and	r24, r24
 372:	c9 f0       	breq	.+50     	; 0x3a6 <SW_ST+0x3a>
 374:	81 30       	cpi	r24, 0x01	; 1
 376:	09 f0       	breq	.+2      	; 0x37a <SW_ST+0xe>
 378:	5e c0       	rjmp	.+188    	; 0x436 <__EEPROM_REGION_LENGTH__+0x36>
	{
		case NORMAL_MODE :
			setting_state_flag = 0 ;
 37a:	10 92 9e 00 	sts	0x009E, r1	; 0x80009e <setting_state_flag+0x1>
 37e:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <setting_state_flag>
			segment7_display(sensed_temp) ;
 382:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 386:	0e 94 66 02 	call	0x4cc	; 0x4cc <segment7_display>
			if ( (GPIO_u8GetPortValue(UP_PORT) == 0b00010000) || (GPIO_u8GetPortValue(DOWN_PORT) == 0b00001000) )
 38a:	81 e0       	ldi	r24, 0x01	; 1
 38c:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <GPIO_u8GetPortValue>
 390:	80 31       	cpi	r24, 0x10	; 16
 392:	31 f0       	breq	.+12     	; 0x3a0 <SW_ST+0x34>
 394:	81 e0       	ldi	r24, 0x01	; 1
 396:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <GPIO_u8GetPortValue>
 39a:	88 30       	cpi	r24, 0x08	; 8
 39c:	09 f0       	breq	.+2      	; 0x3a0 <SW_ST+0x34>
 39e:	4b c0       	rjmp	.+150    	; 0x436 <__EEPROM_REGION_LENGTH__+0x36>
			{
				current_mode = SETTING_MODE ;
 3a0:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <current_mode>
 3a4:	08 95       	ret
			}
			break;
		
		case SETTING_MODE :
		{
			segment7_display(set_temp) ;
 3a6:	80 91 a3 00 	lds	r24, 0x00A3	; 0x8000a3 <set_temp>
 3aa:	0e 94 66 02 	call	0x4cc	; 0x4cc <segment7_display>
			
			if ( setting_state_flag < 500 )
 3ae:	80 91 9d 00 	lds	r24, 0x009D	; 0x80009d <setting_state_flag>
 3b2:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <setting_state_flag+0x1>
 3b6:	84 3f       	cpi	r24, 0xF4	; 244
 3b8:	91 40       	sbci	r25, 0x01	; 1
 3ba:	80 f5       	brcc	.+96     	; 0x41c <__EEPROM_REGION_LENGTH__+0x1c>
			{
				if ( (set_temp < MAX_TEMP) && (GPIO_u8GetPortValue(UP_PORT) == 0b00001000) )
 3bc:	80 91 a3 00 	lds	r24, 0x00A3	; 0x8000a3 <set_temp>
 3c0:	8b 34       	cpi	r24, 0x4B	; 75
 3c2:	78 f4       	brcc	.+30     	; 0x3e2 <SW_ST+0x76>
 3c4:	81 e0       	ldi	r24, 0x01	; 1
 3c6:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <GPIO_u8GetPortValue>
 3ca:	88 30       	cpi	r24, 0x08	; 8
 3cc:	51 f4       	brne	.+20     	; 0x3e2 <SW_ST+0x76>
				{
					set_temp += TEMP_CHANGE ;
 3ce:	80 91 a3 00 	lds	r24, 0x00A3	; 0x8000a3 <set_temp>
 3d2:	8b 5f       	subi	r24, 0xFB	; 251
 3d4:	80 93 a3 00 	sts	0x00A3, r24	; 0x8000a3 <set_temp>
					setting_state_flag = 0 ;
 3d8:	10 92 9e 00 	sts	0x009E, r1	; 0x80009e <setting_state_flag+0x1>
 3dc:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <setting_state_flag>
 3e0:	08 95       	ret
				}
				else if ( (set_temp > MIN_TEMP) && (GPIO_u8GetPortValue(DOWN_PORT) == 0b00010000) )
 3e2:	80 91 a3 00 	lds	r24, 0x00A3	; 0x8000a3 <set_temp>
 3e6:	84 32       	cpi	r24, 0x24	; 36
 3e8:	78 f0       	brcs	.+30     	; 0x408 <__EEPROM_REGION_LENGTH__+0x8>
 3ea:	81 e0       	ldi	r24, 0x01	; 1
 3ec:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <GPIO_u8GetPortValue>
 3f0:	80 31       	cpi	r24, 0x10	; 16
 3f2:	51 f4       	brne	.+20     	; 0x408 <__EEPROM_REGION_LENGTH__+0x8>
				{
					set_temp -= TEMP_CHANGE ;
 3f4:	80 91 a3 00 	lds	r24, 0x00A3	; 0x8000a3 <set_temp>
 3f8:	85 50       	subi	r24, 0x05	; 5
 3fa:	80 93 a3 00 	sts	0x00A3, r24	; 0x8000a3 <set_temp>
					setting_state_flag = 0 ;
 3fe:	10 92 9e 00 	sts	0x009E, r1	; 0x80009e <setting_state_flag+0x1>
 402:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <setting_state_flag>
 406:	08 95       	ret
				}
				else
				{
					setting_state_flag += 20 ;
 408:	80 91 9d 00 	lds	r24, 0x009D	; 0x80009d <setting_state_flag>
 40c:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <setting_state_flag+0x1>
 410:	44 96       	adiw	r24, 0x14	; 20
 412:	90 93 9e 00 	sts	0x009E, r25	; 0x80009e <setting_state_flag+0x1>
 416:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <setting_state_flag>
 41a:	08 95       	ret
				}
			}
			else
			{
				current_mode = NORMAL_MODE ;
 41c:	81 e0       	ldi	r24, 0x01	; 1
 41e:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <current_mode>
				setting_state_flag = 0 ;
 422:	10 92 9e 00 	sts	0x009E, r1	; 0x80009e <setting_state_flag+0x1>
 426:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <setting_state_flag>
				Save_Last_Temp() ;
 42a:	0e 94 90 05 	call	0xb20	; 0xb20 <Save_Last_Temp>
				segment7_display(sensed_temp) ;
 42e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 432:	0e 94 66 02 	call	0x4cc	; 0x4cc <segment7_display>
 436:	08 95       	ret
